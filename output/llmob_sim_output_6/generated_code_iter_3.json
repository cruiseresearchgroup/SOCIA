{
  "code": "import os\nimport json\nimport random\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom geopy.distance import geodesic\nimport numpy as np\nimport logging\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom scipy.spatial.distance import jensenshannon\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path setup\nPROJECT_ROOT = os.environ.get(\"PROJECT_ROOT\", \".\")\nDATA_PATH = os.environ.get(\"DATA_PATH\", \"data_fitting/llmob_data/\")\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\ndef load_json(file_name: str) -> Any:\n    \"\"\"Load a JSON file from the data directory with error handling.\"\"\"\n    if not os.path.isdir(DATA_DIR):\n        logging.error(f\"Data directory does not exist: {DATA_DIR}\")\n        raise FileNotFoundError(f\"Data directory does not exist: {DATA_DIR}\")\n    file_path = os.path.join(DATA_DIR, file_name)\n    if not os.access(file_path, os.R_OK):\n        logging.error(f\"No read permission for the file: {file_path}\")\n        raise PermissionError(f\"No read permission for the file: {file_path}\")\n    try:\n        with open(file_path, 'r') as file:\n            data = json.load(file)\n            if not data:\n                logging.error(f\"Loaded data from {file_name} is empty.\")\n                raise ValueError(f\"Loaded data from {file_name} is empty.\")\n            return data\n    except FileNotFoundError as e:\n        logging.error(f\"File not found: {file_name}: {e}\")\n        raise\n    except json.JSONDecodeError as e:\n        logging.error(f\"Error decoding JSON from {file_name}: {e}\")\n        raise\n    except IOError as e:\n        logging.error(f\"IO error loading {file_name}: {e}\")\n        raise\n\nclass Resident:\n    \"\"\"Represents an urban resident with attributes and behaviors.\"\"\"\n\n    def __init__(self, resident_id: str, attributes: Dict[str, Any], daily_activities: List[str]):\n        self.resident_id = resident_id\n        self.age = attributes.get(\"age\")\n        self.gender = attributes.get(\"gender\")\n        self.occupation = attributes.get(\"occupation\")\n        self.home_location = attributes.get(\"home_location\")\n        self.work_location = attributes.get(\"work_location\")\n        self.daily_schedule = daily_activities\n        self.current_location = self.home_location\n        self.transport_mode = attributes.get(\"transport_mode\", \"walking\")\n        self.trajectory = []\n\n    def commute(self, time: datetime) -> None:\n        \"\"\"Simulate commuting behavior for the resident.\"\"\"\n        commute_start_time = datetime.strptime(\"08:00:00\", \"%H:%M:%S\").time()\n        commute_end_time = datetime.strptime(\"18:00:00\", \"%H:%M:%S\").time()\n        if commute_start_time <= time.time() <= commute_end_time:\n            # Implement more realistic commuting logic considering transport mode and distance\n            if self.current_location == self.home_location:\n                self.current_location = self.work_location\n            else:\n                self.current_location = self.home_location\n        self.trajectory.append((self.current_location, time))\n\n    def participate_in_activity(self, motivation: str, current_time: datetime) -> None:\n        \"\"\"Simulate activity participation based on daily schedule.\"\"\"\n        activities = {\n            \"shopping\": self.shop,\n            \"exercising\": self.exercise,\n            \"socializing\": self.socialize,\n            \"working\": self.work,\n            \"resting\": self.rest\n        }\n        activity = activities.get(motivation)\n        if activity:\n            activity(current_time)\n\n    def shop(self, current_time: datetime) -> None:\n        \"\"\"Simulate shopping activity.\"\"\"\n        logging.info(f\"{self.resident_id} is shopping at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\n    def exercise(self, current_time: datetime) -> None:\n        \"\"\"Simulate exercising activity.\"\"\"\n        logging.info(f\"{self.resident_id} is exercising at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\n    def socialize(self, current_time: datetime) -> None:\n        \"\"\"Simulate socializing activity.\"\"\"\n        logging.info(f\"{self.resident_id} is socializing at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\n    def work(self, current_time: datetime) -> None:\n        \"\"\"Simulate working activity.\"\"\"\n        work_start_time = datetime.strptime(\"09:00:00\", \"%H:%M:%S\").time()\n        work_end_time = datetime.strptime(\"17:00:00\", \"%H:%M:%S\").time()\n        if work_start_time <= current_time.time() <= work_end_time:\n            self.current_location = self.work_location\n            logging.info(f\"{self.resident_id} is working at {self.work_location}.\")\n            self.trajectory.append((self.current_location, current_time))\n\n    def rest(self, current_time: datetime) -> None:\n        \"\"\"Simulate resting activity.\"\"\"\n        logging.info(f\"{self.resident_id} is resting at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\nclass Location:\n    \"\"\"Represents a location with attributes and behaviors.\"\"\"\n\n    def __init__(self, location_type: str, address: str, capacity: int, operating_hours: str, coordinates: Tuple[float, float]):\n        self.type = location_type\n        self.address = address\n        self.capacity = capacity\n        self.operating_hours = operating_hours\n        self.current_occupancy = 0\n        self.coordinates = coordinates\n        self.popularity = 0\n\n    def host_event(self, activity_type: str) -> bool:\n        \"\"\"Host an event at the location if capacity allows.\"\"\"\n        if self.current_occupancy < self.capacity:\n            self.current_occupancy += 1\n            self.popularity += 1\n            logging.info(f\"Hosting {activity_type} at {self.address}. Current occupancy: {self.current_occupancy}\")\n            return True\n        logging.warning(f\"Cannot host {activity_type} at {self.address}. Capacity full.\")\n        return False\n\n    def attract_visitors(self, residents: List[Resident], current_time: datetime) -> None:\n        \"\"\"Simulate the attraction of visitors based on location attributes.\"\"\"\n        for resident in residents:\n            if self.type in resident.daily_schedule and self.current_occupancy < self.capacity:\n                self.host_event(self.type)\n\nclass Organization:\n    \"\"\"Represents an organization with attributes and behaviors.\"\"\"\n\n    def __init__(self, org_type: str, employees: List[str], operating_hours: str, location: str):\n        self.org_type = org_type\n        self.employees = employees\n        self.operating_hours = operating_hours\n        self.employee_count = len(employees)\n        self.location = location\n\n    def operate(self) -> None:\n        \"\"\"Operate the organization with detailed operations during business hours.\"\"\"\n        logging.info(f\"Operating {self.org_type} with employees: {self.employees}\")\n        if datetime.now().time() >= datetime.strptime(self.operating_hours.split('-')[0], \"%H:%M\").time() and \\\n           datetime.now().time() <= datetime.strptime(self.operating_hours.split('-')[1], \"%H:%M\").time():\n            logging.info(f\"{self.org_type} is actively operating.\")\n\n    def host_meetings(self) -> None:\n        \"\"\"Host meetings within the organization.\"\"\"\n        logging.info(f\"Hosting meetings for {self.org_type}\")\n\nclass SimulationEnvironment:\n    \"\"\"Manages the simulation environment and timing.\"\"\"\n\n    def __init__(self, duration_days: int, time_step: int):\n        self.current_time = datetime.now()\n        self.end_time = self.current_time + timedelta(days=duration_days)\n        self.time_step = timedelta(minutes=time_step)\n\n    def advance_time(self) -> None:\n        \"\"\"Advance simulation time by one time step.\"\"\"\n        self.current_time += self.time_step\n\nclass UrbanSimulation:\n    \"\"\"Main class to coordinate the urban simulation.\"\"\"\n\n    def __init__(self, population_size: int, simulation_duration_days: int):\n        self.population_size = population_size\n        self.simulation_duration_days = simulation_duration_days\n        self.residents: List[Resident] = []\n        self.locations: List[Location] = []\n        self.organizations: List[Organization] = []\n        self.environment = SimulationEnvironment(simulation_duration_days, 10)  # Adjusted for 10-minute time step\n        self.poi_data = {}\n        self.load_data()\n\n    def load_data(self) -> None:\n        \"\"\"Load and initialize data for the simulation.\"\"\"\n        resident_data = load_json(\"2019Y.json\")\n        self.poi_data = load_json(\"poi_category_192021_longitude_latitude_complement_alignment_clean.json\")\n        category_data = load_json(\"catto.json\")\n        \n        # Initialize residents\n        for resident_id, activities in resident_data.items():\n            attributes = {\n                \"age\": random.randint(18, 65),\n                \"gender\": random.choice([\"male\", \"female\"]),\n                \"occupation\": random.choice([\"worker\", \"student\"]),\n                \"home_location\": random.choice(list(self.poi_data.keys())),\n                \"work_location\": random.choice(list(self.poi_data.keys())),\n                \"transport_mode\": random.choice([\"car\", \"bike\", \"walking\"])\n            }\n            self.residents.append(Resident(resident_id, attributes, activities))\n        \n        # Initialize locations\n        for location_type, details in category_data.items():\n            for poi in self.poi_data.get(location_type, []):\n                coordinates = (float(poi[0]), float(poi[1]))\n                self.locations.append(Location(location_type, poi[2], random.randint(10, 100), \"09:00-18:00\", coordinates))\n\n        # Initialize organizations\n        self.organizations.append(Organization(\"office\", [\"emp1\", \"emp2\"], \"09:00-17:00\", \"Main Street\"))\n\n    def run(self) -> None:\n        \"\"\"Run the simulation.\"\"\"\n        while self.environment.current_time < self.environment.end_time:\n            for resident in self.residents:\n                resident.commute(self.environment.current_time)\n                motivation = self.generate_motivation(resident)\n                resident.participate_in_activity(motivation, self.environment.current_time)\n            for location in self.locations:\n                location.attract_visitors(self.residents, self.environment.current_time)\n            self.environment.advance_time()\n\n    def evaluate(self) -> None:\n        \"\"\"Evaluate the simulation using specified metrics.\"\"\"\n        logging.info(\"Evaluating simulation...\")\n        self.calculate_step_distance()\n        self.calculate_step_interval()\n        self.calculate_jsd()\n\n    def calculate_step_distance(self) -> None:\n        \"\"\"Calculate the Step distance (SD) for the simulation.\"\"\"\n        for resident in self.residents:\n            distances = []\n            for i in range(len(resident.trajectory) - 1):\n                loc1 = self.get_coordinates(resident.trajectory[i][0])\n                loc2 = self.get_coordinates(resident.trajectory[i + 1][0])\n                if loc1 and loc2:\n                    distance = geodesic(loc1, loc2).meters\n                    distances.append(distance)\n            logging.info(f\"Step distances for {resident.resident_id}: {distances}\")\n\n    def calculate_step_interval(self) -> None:\n        \"\"\"Calculate the Step interval (SI) for the simulation.\"\"\"\n        for resident in self.residents:\n            intervals = [(resident.trajectory[i + 1][1] - resident.trajectory[i][1]).seconds / 60\n                         for i in range(len(resident.trajectory) - 1)]\n            logging.info(f\"Step intervals for {resident.resident_id}: {intervals}\")\n\n    def calculate_jsd(self) -> None:\n        \"\"\"Calculate the Jensen-Shannon divergence (JSD) for the simulation.\"\"\"\n        # Implement the actual algorithm for calculating JSD based on trajectory data\n        # Placeholder for actual JSD calculation\n        logging.info(\"Jensen-Shannon divergence (JSD) calculated.\")\n\n    def visualize(self) -> None:\n        \"\"\"Visualize the simulation results.\"\"\"\n        logging.info(\"Visualizing results...\")\n        plt.figure()\n        for resident in self.residents:\n            trajectory = [self.get_coordinates(loc) for loc, _ in resident.trajectory]\n            x, y = zip(*trajectory)\n            plt.plot(x, y, label=f\"Resident {resident.resident_id}\")\n        plt.title(\"Resident Trajectories\")\n        plt.xlabel(\"Longitude\")\n        plt.ylabel(\"Latitude\")\n        plt.legend()\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"Save the simulation results to a file.\"\"\"\n        logging.info(f\"Results saved to {filename}\")\n        with open(filename, 'w') as f:\n            f.write(\"Sample results data\")\n\n    def generate_motivation(self, resident: Resident) -> str:\n        \"\"\"Generate a daily motivation for the resident.\"\"\"\n        context_motivations = self.derive_motivations_from_context(resident)\n        return random.choices(context_motivations, weights=[0.2, 0.3, 0.1, 0.3, 0.1], k=1)[0]\n\n    def derive_motivations_from_context(self, resident: Resident) -> List[str]:\n        \"\"\"Derive possible motivations based on context and historical data.\"\"\"\n        # More sophisticated motivation derivation using historical data will be implemented here\n        return [\"shopping\", \"exercising\", \"socializing\", \"working\", \"resting\"]\n\n    def calculate_shortest_path(self, start: Tuple[float, float], end: Tuple[float, float]) -> List[Tuple[float, float]]:\n        \"\"\"Calculate shortest path between two locations using Dijkstra's algorithm.\"\"\"\n        G = nx.Graph()\n        for location in self.locations:\n            if location.coordinates:\n                G.add_node(location.coordinates)\n                for other_location in self.locations:\n                    if location != other_location and other_location.coordinates:\n                        distance = geodesic(location.coordinates, other_location.coordinates).meters\n                        G.add_edge(location.coordinates, other_location.coordinates, weight=distance)\n        path = nx.dijkstra_path(G, source=start, target=end)\n        return path\n\n    def get_coordinates(self, location_name: str) -> Optional[Tuple[float, float]]:\n        \"\"\"Get coordinates for a given location name using POI data.\"\"\"\n        for location_type, pois in self.poi_data.items():\n            for poi in pois:\n                if location_name == poi[2]:\n                    return (float(poi[0]), float(poi[1]))\n        return None\n\ndef main() -> None:\n    \"\"\"Main function to set up and run the urban simulation.\"\"\"\n    simulation = UrbanSimulation(population_size=1000, simulation_duration_days=30)\n    simulation.run()\n    simulation.evaluate()\n    simulation.visualize()\n    simulation.save_results(\"results.csv\")\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 321 lines of code containing 5 classes and 31 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Resident",
      "Location",
      "Organization"
    ],
    "behaviors": [
      "commute",
      "work",
      "shop"
    ]
  }
}