{
  "code": "import os\nimport json\nimport random\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom geopy.distance import geodesic\nimport numpy as np\nimport logging\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom scipy.spatial.distance import jensenshannon\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path setup\nPROJECT_ROOT = os.environ.get(\"PROJECT_ROOT\", \".\")\nDATA_PATH = os.environ.get(\"DATA_PATH\", \"data_fitting/llmob_data/\")\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\ndef load_json(file_name: str) -> Any:\n    \"\"\"Load a JSON file from the data directory with error handling.\"\"\"\n    file_path = os.path.join(DATA_DIR, file_name)\n    if not os.path.exists(file_path):\n        logging.error(f\"File does not exist: {file_path}\")\n        raise FileNotFoundError(f\"File does not exist: {file_path}\")\n    if not os.access(file_path, os.R_OK):\n        logging.error(f\"No read permission for the file: {file_path}\")\n        raise PermissionError(f\"No read permission for the file: {file_path}\")\n    try:\n        with open(file_path, 'r') as file:\n            data = json.load(file)\n            if not data:\n                logging.error(f\"Loaded data from {file_name} is empty.\")\n                raise ValueError(f\"Loaded data from {file_name} is empty.\")\n            return data\n    except json.JSONDecodeError as e:\n        logging.error(f\"Error decoding JSON from {file_name}: {e}\")\n        raise\n    except IOError as e:\n        logging.error(f\"IO error loading {file_name}: {e}\")\n        raise\n\nclass Resident:\n    \"\"\"Represents an urban resident with attributes and behaviors.\"\"\"\n    \n    def __init__(self, resident_id: str, attributes: Dict[str, Any], daily_activities: List[str]):\n        self.resident_id = resident_id\n        self.age = attributes.get(\"age\")\n        self.gender = attributes.get(\"gender\")\n        self.occupation = attributes.get(\"occupation\")\n        self.home_location = attributes.get(\"home_location\")\n        self.work_location = attributes.get(\"work_location\")\n        self.daily_schedule = daily_activities\n        self.current_location = self.home_location\n        self.transport_mode = attributes.get(\"transport_mode\", \"walking\")\n        self.trajectory = []\n\n    def commute(self, time: datetime) -> None:\n        \"\"\"Simulate commuting behavior for the resident.\"\"\"\n        commute_start_time = datetime.strptime(\"08:00:00\", \"%H:%M:%S\").time()\n        commute_end_time = datetime.strptime(\"18:00:00\", \"%H:%M:%S\").time()\n        if commute_start_time <= time.time() <= commute_end_time:\n            if self.current_location == self.home_location:\n                self.current_location = self.work_location\n            else:\n                self.current_location = self.home_location\n        self.trajectory.append((self.current_location, time))\n\n    def participate_in_activity(self, motivation: str, current_time: datetime) -> None:\n        \"\"\"Simulate activity participation based on daily schedule.\"\"\"\n        activities = {\n            \"shopping\": self.shop,\n            \"exercising\": self.exercise,\n            \"socializing\": self.socialize,\n            \"working\": self.work,\n            \"resting\": self.rest\n        }\n        activity = activities.get(motivation)\n        if activity:\n            activity(current_time)\n\n    def shop(self, current_time: datetime) -> None:\n        \"\"\"Simulate shopping activity.\"\"\"\n        logging.info(f\"{self.resident_id} is shopping at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\n    def exercise(self, current_time: datetime) -> None:\n        \"\"\"Simulate exercising activity.\"\"\"\n        logging.info(f\"{self.resident_id} is exercising at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\n    def socialize(self, current_time: datetime) -> None:\n        \"\"\"Simulate socializing activity.\"\"\"\n        logging.info(f\"{self.resident_id} is socializing at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\n    def work(self, current_time: datetime) -> None:\n        \"\"\"Simulate working activity.\"\"\"\n        work_start_time = datetime.strptime(\"09:00:00\", \"%H:%M:%S\").time()\n        work_end_time = datetime.strptime(\"17:00:00\", \"%H:%M:%S\").time()\n        if work_start_time <= current_time.time() <= work_end_time:\n            self.current_location = self.work_location\n            logging.info(f\"{self.resident_id} is working at {self.work_location}.\")\n            self.trajectory.append((self.current_location, current_time))\n\n    def rest(self, current_time: datetime) -> None:\n        \"\"\"Simulate resting activity.\"\"\"\n        logging.info(f\"{self.resident_id} is resting at {self.current_location}.\")\n        self.trajectory.append((self.current_location, current_time))\n\nclass Location:\n    \"\"\"Represents a location with attributes and behaviors.\"\"\"\n\n    def __init__(self, location_type: str, address: str, capacity: int, operating_hours: str, coordinates: Tuple[float, float]):\n        self.type = location_type\n        self.address = address\n        self.capacity = capacity\n        self.operating_hours = operating_hours\n        self.current_occupancy = 0\n        self.coordinates = coordinates\n        self.popularity = 0\n\n    def host_event(self, activity_type: str) -> bool:\n        \"\"\"Host an event at the location if capacity allows.\"\"\"\n        if self.current_occupancy < self.capacity:\n            self.current_occupancy += 1\n            self.popularity += 1\n            logging.info(f\"Hosting {activity_type} at {self.address}. Current occupancy: {self.current_occupancy}\")\n            return True\n        logging.warning(f\"Cannot host {activity_type} at {self.address}. Capacity full.\")\n        return False\n\n    def attract_visitors(self, residents: List[Resident], current_time: datetime) -> None:\n        \"\"\"Simulate the attraction of visitors based on location attributes.\"\"\"\n        for resident in residents:\n            if self.type in resident.daily_schedule and self.current_occupancy < self.capacity:\n                self.host_event(self.type)\n\nclass Organization:\n    \"\"\"Represents an organization with attributes and behaviors.\"\"\"\n\n    def __init__(self, org_type: str, employees: List[str], operating_hours: str, location: str):\n        self.org_type = org_type\n        self.employees = employees\n        self.operating_hours = operating_hours\n        self.employee_count = len(employees)\n        self.location = location\n\n    def operate(self) -> None:\n        \"\"\"Operate the organization with detailed operations during business hours.\"\"\"\n        current_time = datetime.now()\n        start_time, end_time = [datetime.strptime(t, \"%H:%M\").time() for t in self.operating_hours.split('-')]\n        logging.info(f\"Operating {self.org_type} with employees: {self.employees}\")\n        if start_time <= current_time.time() <= end_time:\n            logging.info(f\"{self.org_type} is actively operating.\")\n\n    def host_meetings(self) -> None:\n        \"\"\"Host meetings within the organization.\"\"\"\n        logging.info(f\"Hosting meetings for {self.org_type}\")\n\nclass SimulationEnvironment:\n    \"\"\"Manages the simulation environment and timing.\"\"\"\n\n    def __init__(self, duration_days: int, time_step: int):\n        self.current_time = datetime.now()\n        self.end_time = self.current_time + timedelta(days=duration_days)\n        self.time_step = timedelta(minutes=time_step)\n\n    def advance_time(self) -> None:\n        \"\"\"Advance simulation time by one time step.\"\"\"\n        self.current_time += self.time_step\n\nclass UrbanSimulation:\n    \"\"\"Main class to coordinate the urban simulation.\"\"\"\n    \n    def __init__(self, population_size: int, simulation_duration_days: int, random_seed: int = 42):\n        self.population_size = population_size\n        self.simulation_duration_days = simulation_duration_days\n        self.residents: List[Resident] = []\n        self.locations: List[Location] = []\n        self.organizations: List[Organization] = []\n        self.environment = SimulationEnvironment(simulation_duration_days, 10)  # Adjusted for 10-minute time step\n        self.poi_data = {}\n        self.random_seed = random_seed\n        random.seed(self.random_seed)\n        np.random.seed(self.random_seed)\n        self.load_data()\n\n    def load_data(self) -> None:\n        \"\"\"Load and initialize data for the simulation.\"\"\"\n        try:\n            resident_data = load_json(\"2019Y.json\")\n            self.poi_data = load_json(\"poi_category_192021_longitude_latitude_complement_alignment_clean.json\")\n            category_data = load_json(\"catto.json\")\n            \n            # Initialize residents\n            for resident_id, activities in resident_data.items():\n                attributes = {\n                    \"age\": random.randint(18, 65),\n                    \"gender\": random.choice([\"male\", \"female\"]),\n                    \"occupation\": random.choice([\"worker\", \"student\"]),\n                    \"home_location\": random.choice(list(self.poi_data.keys())),\n                    \"work_location\": random.choice(list(self.poi_data.keys())),\n                    \"transport_mode\": random.choice([\"car\", \"bike\", \"walking\"])\n                }\n                self.residents.append(Resident(resident_id, attributes, activities))\n            \n            # Initialize locations\n            for location_type, details in category_data.items():\n                for poi in self.poi_data.get(location_type, []):\n                    coordinates = (float(poi[0]), float(poi[1]))\n                    self.locations.append(Location(location_type, poi[2], random.randint(10, 100), \"09:00-18:00\", coordinates))\n\n            # Initialize organizations\n            self.organizations.append(Organization(\"office\", [\"emp1\", \"emp2\"], \"09:00-17:00\", \"Main Street\"))\n        except FileNotFoundError as e:\n            logging.error(f\"Error loading data: {e}\")\n            raise\n        except json.JSONDecodeError as e:\n            logging.error(f\"Error decoding JSON: {e}\")\n            raise\n\n    def run(self) -> None:\n        \"\"\"Run the simulation.\"\"\"\n        while self.environment.current_time < self.environment.end_time:\n            for resident in self.residents:\n                resident.commute(self.environment.current_time)\n                motivation = self.generate_motivation(resident)\n                resident.participate_in_activity(motivation, self.environment.current_time)\n            for location in self.locations:\n                location.attract_visitors(self.residents, self.environment.current_time)\n            self.environment.advance_time()\n\n    def evaluate(self) -> None:\n        \"\"\"Evaluate the simulation using specified metrics.\"\"\"\n        logging.info(\"Evaluating simulation...\")\n        self.calculate_step_distance()\n        self.calculate_step_interval()\n        self.calculate_jsd()\n\n    def calculate_step_distance(self) -> None:\n        \"\"\"Calculate the Step distance (SD) for the simulation.\"\"\"\n        for resident in self.residents:\n            distances = []\n            for i in range(len(resident.trajectory) - 1):\n                loc1 = self.get_coordinates(resident.trajectory[i][0])\n                loc2 = self.get_coordinates(resident.trajectory[i + 1][0])\n                if loc1 and loc2:\n                    distance = geodesic(loc1, loc2).meters\n                    distances.append(distance)\n            logging.info(f\"Step distances for {resident.resident_id}: {distances}\")\n\n    def calculate_step_interval(self) -> None:\n        \"\"\"Calculate the Step interval (SI) for the simulation.\"\"\"\n        for resident in self.residents:\n            intervals = [(resident.trajectory[i + 1][1] - resident.trajectory[i][1]).seconds / 60\n                         for i in range(len(resident.trajectory) - 1)]\n            logging.info(f\"Step intervals for {resident.resident_id}: {intervals}\")\n\n    def calculate_jsd(self) -> None:\n        \"\"\"Calculate the Jensen-Shannon divergence (JSD) for the simulation.\"\"\"\n        try:\n            real_data = self.extract_real_data()\n            simulated_data = self.extract_simulated_data()\n            if len(real_data) == len(simulated_data):\n                jsd_value = jensenshannon(real_data, simulated_data)\n                logging.info(f\"Jensen-Shannon divergence (JSD): {jsd_value}\")\n            else:\n                logging.error(\"Real and simulated data do not match in length for JSD calculation.\")\n        except Exception as e:\n            logging.error(f\"Error calculating JSD: {e}\")\n\n    def extract_real_data(self) -> np.ndarray:\n        \"\"\"Extract real trajectory data for JSD calculation.\"\"\"\n        real_trajectories = []\n        try:\n            resident_data = load_json(\"2019Y.json\")\n            for activities in resident_data.values():\n                for activity in activities:\n                    time_str = activity.split(\" at \")[1]\n                    real_trajectories.append(datetime.strptime(time_str, \"%H:%M:%S\"))\n        except Exception as e:\n            logging.error(f\"Failed to extract real data: {e}\")\n            raise\n        return np.array(real_trajectories)\n\n    def extract_simulated_data(self) -> np.ndarray:\n        \"\"\"Extract simulated trajectory data for JSD calculation.\"\"\"\n        simulated_trajectories = []\n        for resident in self.residents:\n            for _, time in resident.trajectory:\n                simulated_trajectories.append(time)\n        return np.array(simulated_trajectories)\n\n    def visualize(self) -> None:\n        \"\"\"Visualize the simulation results.\"\"\"\n        logging.info(\"Visualizing results...\")\n        plt.figure()\n        for resident in self.residents:\n            trajectory = [self.get_coordinates(loc) for loc, _ in resident.trajectory if self.get_coordinates(loc)]\n            if trajectory:\n                x, y = zip(*trajectory)\n                plt.plot(x, y, label=f\"Resident {resident.resident_id}\")\n        plt.title(\"Resident Trajectories\")\n        plt.xlabel(\"Longitude\")\n        plt.ylabel(\"Latitude\")\n        plt.legend()\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"Save the simulation results to a file.\"\"\"\n        logging.info(f\"Results saved to {filename}\")\n        with open(filename, 'w') as f:\n            f.write(\"Sample results data\")\n\n    def generate_motivation(self, resident: Resident) -> str:\n        \"\"\"Generate a daily motivation for the resident.\"\"\"\n        historical_data = self.get_historical_data(resident)\n        context_motivations = self.derive_motivations_from_context(resident, historical_data)\n        if context_motivations:\n            return max(context_motivations, key=lambda x: x['probability'])['name']\n        else:\n            return 'resting'\n\n    def get_historical_data(self, resident: Resident) -> List[str]:\n        \"\"\"Retrieve historical data for a resident.\"\"\"\n        try:\n            resident_data = load_json(\"2019Y.json\")\n            return resident_data.get(resident.resident_id, [])\n        except Exception as e:\n            logging.error(f\"Failed to retrieve historical data for {resident.resident_id}: {e}\")\n            return []\n\n    def derive_motivations_from_context(self, resident: Resident, historical_data: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"Derive possible motivations based on context and historical data.\"\"\"\n        motivations = [\"shopping\", \"exercising\", \"socializing\", \"working\", \"resting\"]\n        probabilities = np.random.dirichlet(np.ones(len(motivations)), size=1)[0]\n        return [{\"name\": motivation, \"probability\": prob} for motivation, prob in zip(motivations, probabilities)]\n\n    def calculate_shortest_path(self, start: Tuple[float, float], end: Tuple[float, float]) -> List[Tuple[float, float]]:\n        \"\"\"Calculate shortest path between two locations using Dijkstra's algorithm.\"\"\"\n        G = nx.Graph()\n        for location in self.locations:\n            if location.coordinates:\n                G.add_node(location.coordinates)\n                for other_location in self.locations:\n                    if location != other_location and other_location.coordinates:\n                        distance = geodesic(location.coordinates, other_location.coordinates).meters\n                        G.add_edge(location.coordinates, other_location.coordinates, weight=distance)\n        path = nx.dijkstra_path(G, source=start, target=end)\n        return path\n\n    def get_coordinates(self, location_name: str) -> Optional[Tuple[float, float]]:\n        \"\"\"Get coordinates for a given location name using POI data.\"\"\"\n        for location_type, pois in self.poi_data.items():\n            for poi in pois:\n                if location_name == poi[2]:\n                    return (float(poi[0]), float(poi[1]))\n        return None\n\ndef main() -> None:\n    \"\"\"Main function to set up and run the urban simulation.\"\"\"\n    simulation = UrbanSimulation(population_size=1000, simulation_duration_days=30, random_seed=42)\n    simulation.run()\n    simulation.evaluate()\n    simulation.visualize()\n    simulation.save_results(\"results.csv\")\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 372 lines of code containing 5 classes and 34 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Resident",
      "Location",
      "Organization"
    ],
    "behaviors": [
      "commute",
      "work",
      "shop"
    ]
  }
}