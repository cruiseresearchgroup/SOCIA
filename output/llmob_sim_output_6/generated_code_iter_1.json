{
  "code": "import os\nimport json\nimport random\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom geopy.distance import geodesic\nimport numpy as np\nimport logging\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport networkx as nx\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path setup\nPROJECT_ROOT = os.environ.get(\"PROJECT_ROOT\", \".\")\nDATA_PATH = os.environ.get(\"DATA_PATH\", \"data_fitting/llmob_data/\")\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\n# Load data files\ndef load_json(file_name: str) -> Any:\n    \"\"\"Load a JSON file from the data directory.\"\"\"\n    if not os.path.isdir(DATA_DIR):\n        logging.error(f\"Data directory does not exist: {DATA_DIR}\")\n        return {}\n    try:\n        with open(os.path.join(DATA_DIR, file_name), 'r') as file:\n            return json.load(file)\n    except FileNotFoundError as e:\n        logging.error(f\"File not found: {file_name}: {e}\")\n        return {}\n    except json.JSONDecodeError as e:\n        logging.error(f\"Error decoding JSON from {file_name}: {e}\")\n        return {}\n    except IOError as e:\n        logging.error(f\"IO error loading {file_name}: {e}\")\n        return {}\n\n# Entity: Resident\nclass Resident:\n    \"\"\"Represents an urban resident with attributes and behaviors.\"\"\"\n\n    def __init__(self, resident_id: str, attributes: Dict[str, Any], daily_activities: List[str]):\n        self.resident_id = resident_id\n        self.age = attributes.get(\"age\")\n        self.gender = attributes.get(\"gender\")\n        self.occupation = attributes.get(\"occupation\")\n        self.home_location = attributes.get(\"home_location\")\n        self.work_location = attributes.get(\"work_location\")\n        self.daily_schedule = daily_activities\n        self.current_location = self.home_location\n\n    def commute(self, time: datetime) -> None:\n        \"\"\"Simulate commuting behavior for the resident.\"\"\"\n        if self.current_location == self.home_location:\n            self.current_location = self.work_location\n        else:\n            self.current_location = self.home_location\n\n    def participate_in_activity(self, motivation: str, current_time: datetime) -> None:\n        \"\"\"Simulate activity participation based on daily schedule.\"\"\"\n        activities = {\n            \"shopping\": self.shop,\n            \"exercising\": self.exercise,\n            \"socializing\": self.socialize,\n            \"working\": self.work,\n            \"resting\": self.rest\n        }\n        activity = activities.get(motivation)\n        if activity:\n            activity(current_time)\n\n    def shop(self, current_time: datetime) -> None:\n        \"\"\"Simulate shopping activity.\"\"\"\n        logging.info(f\"{self.resident_id} is shopping at {self.current_location}.\")\n\n    def exercise(self, current_time: datetime) -> None:\n        \"\"\"Simulate exercising activity.\"\"\"\n        logging.info(f\"{self.resident_id} is exercising at {self.current_location}.\")\n\n    def socialize(self, current_time: datetime) -> None:\n        \"\"\"Simulate socializing activity.\"\"\"\n        logging.info(f\"{self.resident_id} is socializing at {self.current_location}.\")\n\n    def work(self, current_time: datetime) -> None:\n        \"\"\"Simulate working activity.\"\"\"\n        logging.info(f\"{self.resident_id} is working at {self.current_location}.\")\n\n    def rest(self, current_time: datetime) -> None:\n        \"\"\"Simulate resting activity.\"\"\"\n        logging.info(f\"{self.resident_id} is resting at {self.current_location}.\")\n\n# Entity: Location\nclass Location:\n    \"\"\"Represents a location with attributes and behaviors.\"\"\"\n\n    def __init__(self, location_type: str, address: str, capacity: int, operating_hours: str, coordinates: Tuple[float, float]):\n        self.type = location_type\n        self.address = address\n        self.capacity = capacity\n        self.operating_hours = operating_hours\n        self.current_occupancy = 0\n        self.coordinates = coordinates\n\n    def host_activity(self, activity_type: str) -> bool:\n        \"\"\"Host an activity at the location if capacity allows.\"\"\"\n        if self.current_occupancy < self.capacity:\n            self.current_occupancy += 1\n            logging.info(f\"Hosting {activity_type} at {self.address}. Current occupancy: {self.current_occupancy}\")\n            return True\n        logging.warning(f\"Cannot host {activity_type} at {self.address}. Capacity full.\")\n        return False\n\n# Entity: Organization\nclass Organization:\n    \"\"\"Represents an organization with attributes and behaviors.\"\"\"\n\n    def __init__(self, org_type: str, employees: List[str], operating_hours: str):\n        self.org_type = org_type\n        self.employees = employees\n        self.operating_hours = operating_hours\n\n    def operate(self) -> None:\n        \"\"\"Operate the organization.\"\"\"\n        logging.info(f\"Operating {self.org_type} with employees: {self.employees}\")\n\n    def schedule_events(self) -> None:\n        \"\"\"Schedule events within the organization.\"\"\"\n        logging.info(f\"Scheduling events for {self.org_type}\")\n\n# Simulation Environment\nclass SimulationEnvironment:\n    \"\"\"Manages the simulation environment and timing.\"\"\"\n\n    def __init__(self, duration_days: int, time_step: int):\n        self.current_time = datetime.now()\n        self.end_time = self.current_time + timedelta(days=duration_days)\n        self.time_step = timedelta(minutes=time_step)\n\n    def advance_time(self) -> None:\n        \"\"\"Advance simulation time by one time step.\"\"\"\n        self.current_time += self.time_step\n\n# Simulation Class\nclass UrbanSimulation:\n    \"\"\"Main class to coordinate the urban simulation.\"\"\"\n\n    def __init__(self, population_size: int, simulation_duration_days: int):\n        self.population_size = population_size\n        self.simulation_duration_days = simulation_duration_days\n        self.residents: List[Resident] = []\n        self.locations: List[Location] = []\n        self.organizations: List[Organization] = []\n        self.environment = SimulationEnvironment(simulation_duration_days, 10)  # Adjusted for 10-minute time step\n\n    def load_data(self) -> None:\n        \"\"\"Load and initialize data for the simulation.\"\"\"\n        resident_data = load_json(\"2019Y.json\")\n        poi_data = load_json(\"poi_category_192021_longitude_latitude_complement_alignment_clean.json\")\n        category_data = load_json(\"catto.json\")\n        \n        # Initialize residents\n        for resident_id, activities in resident_data.items():\n            attributes = {\n                \"age\": random.randint(18, 65),\n                \"gender\": random.choice([\"male\", \"female\"]),\n                \"occupation\": random.choice([\"worker\", \"student\"]),\n                \"home_location\": random.choice(list(poi_data.keys())),\n                \"work_location\": random.choice(list(poi_data.keys()))\n            }\n            self.residents.append(Resident(resident_id, attributes, activities))\n        \n        # Initialize locations\n        for location_type, details in category_data.items():\n            for poi in poi_data.get(location_type, []):\n                coordinates = (float(poi[0]), float(poi[1]))\n                self.locations.append(Location(location_type, poi[2], random.randint(10, 100), \"09:00-18:00\", coordinates))\n\n        # Initialize organizations\n        self.organizations.append(Organization(\"office\", [\"emp1\", \"emp2\"], \"09:00-17:00\"))\n\n    def run(self) -> None:\n        \"\"\"Run the simulation.\"\"\"\n        while self.environment.current_time < self.environment.end_time:\n            for resident in self.residents:\n                resident.commute(self.environment.current_time)\n                motivation = self.generate_motivation(resident)\n                resident.participate_in_activity(motivation, self.environment.current_time)\n            self.environment.advance_time()\n\n    def evaluate(self) -> None:\n        \"\"\"Evaluate the simulation using specified metrics.\"\"\"\n        logging.info(\"Evaluating simulation...\")\n\n    def visualize(self) -> None:\n        \"\"\"Visualize the simulation results.\"\"\"\n        logging.info(\"Visualizing results...\")\n        plt.figure()\n        plt.title(\"Simulation Results\")\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"Save the simulation results to a file.\"\"\"\n        logging.info(f\"Results saved to {filename}\")\n        with open(filename, 'w') as f:\n            f.write(\"Sample results data\")\n\n    def generate_motivation(self, resident: Resident) -> str:\n        \"\"\"Generate a daily motivation for the resident.\"\"\"\n        context_motivations = self.derive_motivations_from_context(resident)\n        return random.choices(context_motivations, weights=[0.2, 0.3, 0.1, 0.3, 0.1])[0]\n\n    def derive_motivations_from_context(self, resident: Resident) -> List[str]:\n        \"\"\"Derive possible motivations based on context and historical data.\"\"\"\n        # Implement logic to analyze historical trajectory data\n        historical_patterns = [\"shopping\", \"exercising\", \"socializing\", \"working\", \"resting\"]\n        # Example enhancement: analyze trajectories to refine motivations\n        # This needs access to real trajectory data and meaningful analysis\n        return historical_patterns\n\n    def calculate_shortest_path(self, start: Tuple[float, float], end: Tuple[float, float]) -> List[Tuple[float, float]]:\n        \"\"\"Calculate shortest path between two locations using Dijkstra's algorithm.\"\"\"\n        G = nx.Graph()\n        # Assume nodes are created based on some logic, e.g., POIs data\n        for location in self.locations:\n            G.add_node(location.coordinates)\n            # Add edges based on hypothetical distances, replace with real logic\n            for other_location in self.locations:\n                if location != other_location:\n                    distance = geodesic(location.coordinates, other_location.coordinates).meters\n                    G.add_edge(location.coordinates, other_location.coordinates, weight=distance)\n        path = nx.dijkstra_path(G, source=start, target=end)\n        return path\n\ndef main() -> None:\n    \"\"\"Entry point for the simulation.\"\"\"\n    simulation = UrbanSimulation(population_size=1000, simulation_duration_days=30)\n    simulation.load_data()\n    simulation.run()\n    simulation.evaluate()\n    simulation.visualize()\n    simulation.save_results(\"results.csv\")\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 246 lines of code containing 5 classes and 26 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Resident",
      "Location",
      "Organization"
    ],
    "behaviors": [
      "Commute",
      "Shop",
      "Exercise"
    ]
  }
}