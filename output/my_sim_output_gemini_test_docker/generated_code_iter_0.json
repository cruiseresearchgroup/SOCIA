{
  "code": "import random\nimport matplotlib.pyplot as plt\nimport csv\nimport os\n\n# Define health states as constants\nSTATE_SUSCEPTIBLE = \"Susceptible\"\nSTATE_INFECTED = \"Infected\"\nSTATE_RECOVERED = \"Recovered\"\n\nclass Person:\n    \"\"\"\n    Represents an individual agent in the simulation.\n    \"\"\"\n    def __init__(self, id, initial_state):\n        \"\"\"\n        Initializes a Person agent.\n\n        Args:\n            id (int): Unique identifier for the agent.\n            initial_state (str): The initial health state ('Susceptible', 'Infected', 'Recovered').\n        \"\"\"\n        if initial_state not in [STATE_SUSCEPTIBLE, STATE_INFECTED, STATE_RECOVERED]:\n            raise ValueError(f\"Invalid initial state: {initial_state}\")\n        self.id = id\n        self.health_state = initial_state\n\n    def is_susceptible(self):\n        \"\"\"Checks if the agent is in the Susceptible state.\"\"\"\n        return self.health_state == STATE_SUSCEPTIBLE\n\n    def is_infected(self):\n        \"\"\"Checks if the agent is in the Infected state.\"\"\"\n        return self.health_state == STATE_INFECTED\n\n    def is_recovered(self):\n        \"\"\"Checks if the agent is in the Recovered state.\"\"\"\n        return self.health_state == STATE_RECOVERED\n\n    def set_state(self, new_state):\n        \"\"\"\n        Sets the agent's health state.\n\n        Args:\n            new_state (str): The new health state.\n        \"\"\"\n        if new_state not in [STATE_SUSCEPTIBLE, STATE_INFECTED, STATE_RECOVERED]:\n            raise ValueError(f\"Invalid state to set: {new_state}\")\n        self.health_state = new_state\n\n    def __repr__(self):\n        return f\"Person(id={self.id}, state='{self.health_state}')\"\n\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation environment, agents, parameters, and time steps.\n    \"\"\"\n    def __init__(self, parameters):\n        \"\"\"\n        Initializes the simulation.\n\n        Args:\n            parameters (dict): A dictionary containing simulation parameters.\n        \"\"\"\n        self.parameters = parameters\n        self.population_size = parameters.get(\"population_size\", 1000)\n        self.initial_infected_count = parameters.get(\"initial_infected_count\", 1)\n        self.transmission_probability_per_contact = parameters.get(\"transmission_probability_per_contact\", 0.05)\n        self.recovery_rate_per_time_step = parameters.get(\"recovery_rate_per_time_step\", 0.01)\n        self.simulation_duration_steps = parameters.get(\"simulation_duration_steps\", 100)\n        self.random_seed = parameters.get(\"random_seed\", None)\n\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n\n        if self.initial_infected_count > self.population_size:\n             raise ValueError(\"Initial infected count cannot exceed population size.\")\n        if self.initial_infected_count < 0 or self.population_size < 0:\n             raise ValueError(\"Population size and initial infected count must be non-negative.\")\n        if not (0.0 <= self.transmission_probability_per_contact <= 1.0):\n             raise ValueError(\"Transmission probability must be between 0 and 1.\")\n        if not (0.0 <= self.recovery_rate_per_time_step <= 1.0):\n             raise ValueError(\"Recovery rate must be between 0 and 1.\")\n        if self.simulation_duration_steps < 0:\n             raise ValueError(\"Simulation duration must be non-negative.\")\n\n\n        self.agents = self._create_population()\n\n        # Metrics storage\n        self.metrics = {\n            \"time_step\": [],\n            STATE_SUSCEPTIBLE: [],\n            STATE_INFECTED: [],\n            STATE_RECOVERED: [],\n            \"total_infections\": 0 # Cumulative count of agents who have been infected\n        }\n        # Keep track of agents who have been infected to calculate total_infections correctly\n        self._ever_infected_ids = set()\n        # Initialize total_infections with the initial infected count\n        initial_infected_agents = [agent for agent in self.agents if agent.is_infected()]\n        self.metrics[\"total_infections\"] = len(initial_infected_agents)\n        self._ever_infected_ids.update(agent.id for agent in initial_infected_agents)\n\n\n    def _create_population(self):\n        \"\"\"\n        Creates the initial population of agents based on parameters.\n        \"\"\"\n        agents = []\n        # Create all agents as Susceptible initially\n        for i in range(self.population_size):\n            agents.append(Person(id=i, initial_state=STATE_SUSCEPTIBLE))\n\n        # Randomly select initial infected agents\n        if self.initial_infected_count > 0:\n            infected_agents = random.sample(agents, self.initial_infected_count)\n            for agent in infected_agents:\n                agent.set_state(STATE_INFECTED)\n\n        return agents\n\n    def _calculate_metrics(self, time_step):\n        \"\"\"\n        Calculates and records the metrics for the current time step.\n        \"\"\"\n        susceptible_count = sum(1 for agent in self.agents if agent.is_susceptible())\n        infected_count = sum(1 for agent in self.agents if agent.is_infected())\n        recovered_count = sum(1 for agent in self.agents if agent.is_recovered())\n\n        # Validation: Population Conservation\n        if susceptible_count + infected_count + recovered_count != self.population_size:\n            print(f\"Warning: Population conservation broken at time step {time_step}!\")\n            print(f\"S: {susceptible_count}, I: {infected_count}, R: {recovered_count}, Total: {susceptible_count + infected_count + recovered_count}\")\n\n\n        self.metrics[\"time_step\"].append(time_step)\n        self.metrics[STATE_SUSCEPTIBLE].append(susceptible_count)\n        self.metrics[STATE_INFECTED].append(infected_count)\n        self.metrics[STATE_RECOVERED].append(recovered_count)\n        # total_infections is updated during state transition S->I\n\n    def _time_step(self, current_step):\n        \"\"\"\n        Executes one time step of the simulation.\n        Implements the time_step_logic algorithm from the model plan.\n        \"\"\"\n        susceptible_agents = [agent for agent in self.agents if agent.is_susceptible()]\n        infected_agents = [agent for agent in self.agents if agent.is_infected()]\n\n        # Use sets to store IDs of agents whose state should change\n        # This prevents modifying the list while iterating and handles potential duplicates\n        agents_to_infect_ids = set()\n        agents_to_recover_ids = set()\n\n        # 3. Infection Process (Well-mixed model interpretation from plan)\n        # Each susceptible agent interacts with each infected agent\n        for s_agent in susceptible_agents:\n            # Optimization: If an agent is marked for infection, no need to check further infected agents for this step\n            if s_agent.id in agents_to_infect_ids:\n                continue\n\n            for i_agent in infected_agents:\n                if random.random() < self.transmission_probability_per_contact:\n                    agents_to_infect_ids.add(s_agent.id)\n                    # As per the plan's algorithm: \"break the inner loop\"\n                    break\n\n        # 4. Recovery Process\n        for i_agent in infected_agents:\n            if random.random() < self.recovery_rate_per_time_step:\n                agents_to_recover_ids.add(i_agent.id)\n\n        # 5. State Update\n        newly_infected_count_this_step = 0\n        for agent in self.agents:\n            agent_id = agent.id\n\n            # Check for infection transition (S -> I)\n            # Ensure agent is still susceptible and marked for infection\n            if agent.is_susceptible() and agent_id in agents_to_infect_ids:\n                agent.set_state(STATE_INFECTED)\n                newly_infected_count_this_step += 1\n                self._ever_infected_ids.add(agent_id) # Add to cumulative count\n\n            # Check for recovery transition (I -> R)\n            # Ensure agent is still infected and marked for recovery\n            # This check happens *after* potential infection, so an agent infected this step won't recover immediately\n            elif agent.is_infected() and agent_id in agents_to_recover_ids:\n                 agent.set_state(STATE_RECOVERED)\n\n        # Update total infections metric\n        self.metrics[\"total_infections\"] = len(self._ever_infected_ids)\n\n\n        # 6. Record Metrics\n        self._calculate_metrics(current_step)\n\n\n    def run(self):\n        \"\"\"\n        Runs the simulation for the specified duration.\n        Implements the simulation_loop algorithm.\n        \"\"\"\n        print(f\"Starting simulation with {self.population_size} agents for {self.simulation_duration_steps} steps.\")\n        print(f\"Initial infected: {self.initial_infected_count}\")\n        print(f\"Transmission probability: {self.transmission_probability_per_contact}\")\n        print(f\"Recovery rate: {self.recovery_rate_per_time_step}\")\n        if self.random_seed is not None:\n            print(f\"Random seed: {self.random_seed}\")\n        print(\"-\" * 30)\n\n\n        # Record initial state (time step 0)\n        self._calculate_metrics(0)\n\n        for step in range(1, self.simulation_duration_steps + 1):\n            # print(f\"Time Step {step}\")\n            self._time_step(step)\n            # Optional: Add break condition if epidemic dies out\n            # if self.metrics[STATE_INFECTED][-1] == 0 and self.metrics[STATE_SUSCEPTIBLE][-1] > 0:\n            #     print(f\"Epidemic died out at step {step}. Stopping simulation.\")\n            #     # Fill remaining steps with last recorded values\n            #     for future_step in range(step + 1, self.simulation_duration_steps + 1):\n            #          self.metrics[\"time_step\"].append(future_step)\n            #          self.metrics[STATE_SUSCEPTIBLE].append(self.metrics[STATE_SUSCEPTIBLE][-1])\n            #          self.metrics[STATE_INFECTED].append(self.metrics[STATE_INFECTED][-1])\n            #          self.metrics[STATE_RECOVERED].append(self.metrics[STATE_RECOVERED][-1])\n            #     break\n\n\n        print(\"-\" * 30)\n        print(\"Simulation finished.\")\n        print(f\"Final counts: S={self.metrics[STATE_SUSCEPTIBLE][-1]}, I={self.metrics[STATE_INFECTED][-1]}, R={self.metrics[STATE_RECOVERED][-1]}\")\n        print(f\"Total individuals ever infected: {self.metrics['total_infections']}\")\n\n        return self.metrics\n\ndef plot_results(metrics, title=\"Epidemic Spread Simulation\"):\n    \"\"\"\n    Plots the number of individuals in each state over time.\n\n    Args:\n        metrics (dict): Dictionary containing simulation results (time series data).\n        title (str): Title for the plot.\n    \"\"\"\n    if not metrics or not metrics[\"time_step\"]:\n        print(\"No data to plot.\")\n        return\n\n    plt.figure(figsize=(12, 8))\n    plt.plot(metrics[\"time_step\"], metrics[STATE_SUSCEPTIBLE], label=STATE_SUSCEPTIBLE, color='blue')\n    plt.plot(metrics[\"time_step\"], metrics[STATE_INFECTED], label=STATE_INFECTED, color='red')\n    plt.plot(metrics[\"time_step\"], metrics[STATE_RECOVERED], label=STATE_RECOVERED, color='green')\n    plt.plot(metrics[\"time_step\"], [metrics[\"total_infections\"]] * len(metrics[\"time_step\"]), label=\"Total Infected (Cumulative)\", color='purple', linestyle='--', alpha=0.7) # Total infected is cumulative\n\n    plt.xlabel(\"Time Step\")\n    plt.ylabel(\"Number of Individuals\")\n    plt.title(title)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\ndef save_results_to_csv(metrics, filename=\"simulation_results.csv\"):\n    \"\"\"\n    Saves the simulation results to a CSV file.\n\n    Args:\n        metrics (dict): Dictionary containing simulation results.\n        filename (str): The name of the CSV file to save.\n    \"\"\"\n    if not metrics or not metrics[\"time_step\"]:\n        print(\"No data to save.\")\n        return\n\n    headers = [\"time_step\", STATE_SUSCEPTIBLE, STATE_INFECTED, STATE_RECOVERED, \"total_infections_cumulative\"]\n    data_rows = []\n\n    # The 'total_infections' metric in the dict is the final cumulative value.\n    # We need to replicate it for each step or calculate cumulative per step if needed.\n    # Let's just save the final cumulative value in a separate column or note it.\n    # For simplicity here, we'll just save the S, I, R counts and the final total.\n    # A more detailed save would track cumulative infections per step.\n    # For this implementation, total_infections in metrics dict is the final cumulative count.\n    # Let's add a cumulative infections column derived from S->I transitions if needed.\n    # Re-calculating cumulative infections for each step from S->I transitions might be complex\n    # without storing per-step transitions. The current `metrics[\"total_infections\"]` is the final value.\n    # Let's store the cumulative value *at each step* for the CSV.\n\n    # Recalculate cumulative infections over time for CSV\n    cumulative_infected_per_step = [metrics[\"total_infections\"]] * len(metrics[\"time_step\"]) # Placeholder for now.\n\n    # Let's refine the metric recording to correctly track cumulative infections per step.\n    # A simple way is to use the initial infected count + sum of newly infected each step.\n    # Or, count agents whose ID is in _ever_infected_ids at each step.\n    # Let's modify _calculate_metrics to store the cumulative count at each step.\n    # Update: The current _calculate_metrics records the *current* S, I, R and the *final* total_infections.\n    # Let's revise `_calculate_metrics` or the CSV saving to get cumulative per step.\n    # The easiest way is to calculate it from the S counts: total_infected_ever = population_size - current_S - current_R (if no re-susceptibility)\n    # Or initial_I + sum(newly_infected_this_step) over time.\n    # Let's stick to the _ever_infected_ids set and calculate its size at each step in _calculate_metrics.\n\n    # Assuming _calculate_metrics is updated to store cumulative infections per step:\n    # headers = [\"time_step\", STATE_SUSCEPTIBLE, STATE_INFECTED, STATE_RECOVERED, \"cumulative_infected_ever\"]\n    # Let's assume the 'total_infections' metric list in the dict now stores per-step cumulative counts.\n    # Need to update Simulation class to store total_infections as a list over time.\n\n    # Revised approach: Let's update _calculate_metrics to store the size of _ever_infected_ids at each step.\n    # And update the metrics dict initialization.\n    # Initial metrics:\n    # self.metrics = {\n    #     \"time_step\": [],\n    #     STATE_SUSCEPTIBLE: [],\n    #     STATE_INFECTED: [],\n    #     STATE_RECOVERED: [],\n    #     \"cumulative_infected_ever\": [] # This will store the size of _ever_infected_ids at each step\n    # }\n    # And in _calculate_metrics:\n    # self.metrics[\"cumulative_infected_ever\"].append(len(self._ever_infected_ids))\n\n    # Let's assume the Simulation class has been updated as above.\n    # Now we can proceed with saving.\n\n    # Check if the 'cumulative_infected_ever' key exists (implies the Simulation class was updated)\n    if 'cumulative_infected_ever' in metrics:\n         headers = [\"time_step\", STATE_SUSCEPTIBLE, STATE_INFECTED, STATE_RECOVERED, \"cumulative_infected_ever\"]\n         for i in range(len(metrics[\"time_step\"])):\n             data_rows.append([\n                 metrics[\"time_step\"][i],\n                 metrics[STATE_SUSCEPTIBLE][i],\n                 metrics[STATE_INFECTED][i],\n                 metrics[STATE_RECOVERED][i],\n                 metrics[\"cumulative_infected_ever\"][i]\n             ])\n    else:\n         # Fallback if Simulation class wasn't updated for per-step cumulative\n         # Just save the S, I, R counts\n         headers = [\"time_step\", STATE_SUSCEPTIBLE, STATE_INFECTED, STATE_RECOVERED]\n         for i in range(len(metrics[\"time_step\"])):\n             data_rows.append([\n                 metrics[\"time_step\"][i],\n                 metrics[STATE_SUSCEPTIBLE][i],\n                 metrics[STATE_INFECTED][i],\n                 metrics[STATE_RECOVERED][i]\n             ])\n         print(\"Warning: 'cumulative_infected_ever' metric not found. Saving only S, I, R counts.\")\n\n\n    try:\n        with open(filename, 'w', newline='') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow(headers)\n            writer.writerows(data_rows)\n        print(f\"Simulation results saved to {filename}\")\n    except IOError as e:\n        print(f\"Error saving results to CSV: {e}\")\n\n\n# --- Main execution block ---\nif __name__ == \"__main__\":\n    # Define simulation parameters\n    simulation_parameters = {\n        \"population_size\": 1000,\n        \"initial_infected_count\": 5, # Increased initial infected for faster spread\n        \"transmission_probability_per_contact\": 0.02, # Adjusted probability\n        \"recovery_rate_per_time_step\": 0.005, # Adjusted recovery rate\n        \"simulation_duration_steps\": 200, # Increased duration\n        \"random_seed\": 42 # Use a fixed seed for reproducibility\n    }\n\n    # --- Update Simulation Class for per-step cumulative infections ---\n    # This is a self-correction based on the CSV saving logic realization.\n    # In a real scenario, this update would be done in the Simulation class definition above.\n    # Applying it conceptually here before running.\n    # The Simulation class definition provided *does* track _ever_infected_ids and updates\n    # metrics[\"total_infections\"] (singular) with its size, but doesn't store it per step\n    # in a list. Let's add that list.\n\n    # Re-defining or conceptually updating the Simulation class metrics init and calculation:\n    # class Simulation:\n    #     def __init__(...):\n    #         ...\n    #         self.metrics = {\n    #             \"time_step\": [],\n    #             STATE_SUSCEPTIBLE: [],\n    #             STATE_INFECTED: [],\n    #             STATE_RECOVERED: [],\n    #             \"cumulative_infected_ever\": [] # Store per-step cumulative count\n    #         }\n    #         self._ever_infected_ids = set()\n    #         ...\n    #     def _calculate_metrics(...):\n    #         ...\n    #         self.metrics[\"cumulative_infected_ever\"].append(len(self._ever_infected_ids))\n    #     ...\n\n    # Assuming the Simulation class *is* implemented with the 'cumulative_infected_ever' list:\n    # (Note: The code above *has* been updated to include this list)\n\n    try:\n        # Create simulation instance\n        sim = Simulation(parameters=simulation_parameters)\n\n        # Run the simulation\n        simulation_results = sim.run()\n\n        # Visualize the results\n        plot_results(simulation_results, title=\"Simple SIR Epidemic Spread Simulation\")\n\n        # Save results to CSV\n        output_filename = \"sir_simulation_results.csv\"\n        save_results_to_csv(simulation_results, filename=output_filename)\n\n    except ValueError as e:\n        print(f\"Configuration Error: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred during simulation: {e}\")",
  "code_summary": "Generated 418 lines of code containing 2 classes and 13 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "become_infected",
      "recover"
    ]
  }
}