{
  "code": "import random\nimport math\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\n\n# --- utils.py ---\n\ndef set_random_seed(seed):\n    \"\"\"Sets the random seed for reproducibility.\"\"\"\n    if seed is not None:\n        random.seed(seed)\n        # Note: numpy seed is not needed as numpy is not used for random choices here.\n        # If numpy is used for random operations later, add np.random.seed(seed)\n\n# --- person.py ---\n\nclass Person:\n    \"\"\"\n    Represents an individual agent in the simulation.\n\n    Attributes:\n        id (int): Unique identifier for the person.\n        health_status (str): The current health status ('Susceptible', 'Infected', 'Recovered').\n        days_infected (int): The number of simulation steps the person has been 'Infected'.\n    \"\"\"\n\n    def __init__(self, id, initial_status, days_infected=0):\n        \"\"\"\n        Initializes a new Person agent.\n\n        Args:\n            id (int): The unique ID for the agent.\n            initial_status (str): The starting health status ('Susceptible', 'Infected', 'Recovered').\n            days_infected (int): The initial number of days infected (default is 0).\n        \"\"\"\n        if initial_status not in ['Susceptible', 'Infected', 'Recovered']:\n            raise ValueError(f\"Invalid initial status: {initial_status}\")\n\n        self.id = id\n        self.health_status = initial_status\n        self.days_infected = days_infected\n\n    def update_status(self, mean_infectious_duration):\n        \"\"\"\n        Updates the health status of the person based on rules.\n        Handles the transition from 'Infected' to 'Recovered'.\n\n        Args:\n            mean_infectious_duration (int): The average duration a person is infectious.\n        \"\"\"\n        if self.health_status == 'Infected':\n            self.days_infected += 1\n            # Simple transition: recover after mean_infectious_duration days\n            if self.days_infected > mean_infectious_duration:\n                self.health_status = 'Recovered'\n                # Reset days_infected after recovery, not strictly necessary but good practice\n                self.days_infected = 0\n\n    def __repr__(self):\n        return f\"Person(id={self.id}, status='{self.health_status}', days_infected={self.days_infected})\"\n\n# --- interaction.py ---\n\ndef attempt_infection(person1, person2, infection_probability_per_contact):\n    \"\"\"\n    Attempts to transmit the virus between two people during a contact.\n\n    Args:\n        person1 (Person): The first person involved in the contact.\n        person2 (Person): The second person involved in the contact.\n        infection_probability_per_contact (float): The probability of transmission\n                                                   from an Infected to a Susceptible\n                                                   person during a single contact.\n\n    Returns:\n        list[int]: A list of IDs of persons who became newly infected as a result\n                   of this specific interaction. Returns an empty list if no\n                   new infections occurred. Note: The caller is responsible for\n                   actually changing the status *after* all interactions for\n                   the step are processed, to ensure synchronous updates.\n    \"\"\"\n    newly_infected_ids = []\n\n    # Check if person1 can infect person2\n    if person1.health_status == 'Infected' and person2.health_status == 'Susceptible':\n        if random.random() < infection_probability_per_contact:\n            newly_infected_ids.append(person2.id)\n\n    # Check if person2 can infect person1 (symmetric interaction)\n    if person2.health_status == 'Infected' and person1.health_status == 'Susceptible':\n        if random.random() < infection_probability_per_contact:\n            newly_infected_ids.append(person1.id)\n\n    # Return unique IDs in case the same person was somehow added twice (unlikely here)\n    return list(set(newly_infected_ids))\n\n\n# --- metrics.py ---\n\nclass MetricsCollector:\n    \"\"\"\n    Collects and stores simulation metrics at each step.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the metrics storage.\"\"\"\n        self.data = {\n            'step': [],\n            'susceptible_count': [],\n            'infected_count': [],\n            'recovered_count': [],\n            'total_infections': [], # Cumulative\n            'peak_infected_count': 0 # Maximum value seen so far\n        }\n        self._cumulative_infections = 0 # Internal counter for total infections\n\n    def collect(self, step, population):\n        \"\"\"\n        Collects metrics for the current simulation step.\n\n        Args:\n            step (int): The current simulation step number.\n            population (list[Person]): The list of all agents in the simulation.\n        \"\"\"\n        susceptible = sum(1 for p in population if p.health_status == 'Susceptible')\n        infected = sum(1 for p in population if p.health_status == 'Infected')\n        recovered = sum(1 for p in population if p.health_status == 'Recovered')\n\n        # Calculate newly infected in this step to update cumulative count\n        # This requires comparing state to the previous step, or tracking state changes.\n        # A simpler approach for *cumulative* infections is to count transitions\n        # from Susceptible to Infected *as they happen*.\n        # However, the model plan just asks for total_infections as a metric,\n        # typically meaning cumulative cases. Let's assume it means cumulative\n        # count of people who have *ever* been infected.\n        # A more robust way to track cumulative infections is needed.\n        # Let's refine the definition: total_infections is the count of people\n        # who are currently Infected OR have Recovered. This is a common proxy\n        # for cumulative cases in simple SIR models without births/deaths.\n        cumulative_infections = infected + recovered\n\n        self.data['step'].append(step)\n        self.data['susceptible_count'].append(susceptible)\n        self.data['infected_count'].append(infected)\n        self.data['recovered_count'].append(recovered)\n        self.data['total_infections'].append(cumulative_infections)\n\n        # Update peak infected count\n        self.data['peak_infected_count'] = max(self.data['peak_infected_count'], infected)\n\n        # Basic validation: check population conservation\n        total_population = susceptible + infected + recovered\n        if step > 0 and total_population != self.data['susceptible_count'][0] + self.data['infected_count'][0] + self.data['recovered_count'][0]:\n             print(f\"Warning: Population size changed at step {step}! Expected: {self.data['susceptible_count'][0] + self.data['infected_count'][0] + self.data['recovered_count'][0]}, Got: {total_population}\")\n        elif step == 0 and total_population != len(population):\n             print(f\"Warning: Initial population size mismatch! Expected: {len(population)}, Got: {total_population}\")\n\n\n    def get_dataframe(self):\n        \"\"\"Returns the collected metrics as a pandas DataFrame.\"\"\"\n        return pd.DataFrame(self.data)\n\n    def get_peak_infected(self):\n        \"\"\"Returns the peak number of simultaneously infected individuals.\"\"\"\n        return self.data['peak_infected_count']\n\n# --- simulation.py ---\n\nclass Simulation:\n    \"\"\"\n    Coordinates the agent-based epidemic simulation.\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"\n        Initializes the simulation with parameters.\n\n        Args:\n            parameters (dict): A dictionary containing simulation parameters.\n        \"\"\"\n        self.parameters = parameters\n        self.population = []\n        self.metrics_collector = MetricsCollector()\n\n        # Set random seed if provided\n        set_random_seed(self.parameters.get(\"random_seed\"))\n\n        self.initialize_population()\n\n    def initialize_population(self):\n        \"\"\"\n        Creates and initializes the population of Person agents.\n        \"\"\"\n        pop_size = self.parameters['population_size']\n        initial_infected = self.parameters['initial_infected_count']\n\n        if initial_infected > pop_size:\n            raise ValueError(\"Initial infected count cannot exceed population size.\")\n\n        # Create all agents as Susceptible initially\n        self.population = [Person(id=i, initial_status='Susceptible') for i in range(pop_size)]\n\n        # Randomly select initial infected individuals\n        infected_indices = random.sample(range(pop_size), initial_infected)\n        for i in infected_indices:\n            self.population[i].health_status = 'Infected'\n            self.population[i].days_infected = 0 # Start days_infected at 0\n\n        print(f\"Initialized population: {pop_size} total, {initial_infected} infected.\")\n\n    def run_step(self, step):\n        \"\"\"\n        Executes a single step of the simulation.\n\n        Args:\n            step (int): The current step number.\n        \"\"\"\n        # --- Phase 1: Interactions ---\n        # Identify agents who become infected in this step based on interactions.\n        # Collect IDs first to apply changes synchronously after all interactions.\n        newly_infected_ids_in_this_step = set()\n        pop_size = len(self.population)\n        contacts_per_person = self.parameters['contacts_per_person_per_step']\n        infection_prob = self.parameters['infection_probability_per_contact']\n\n        # To efficiently pick random partners, especially in non-spatial models,\n        # we can shuffle indices or directly sample from the population list.\n        # A common way for 'random mixing' is to pair randomly or pick partners randomly.\n        # The plan says \"randomly selecting another Person agent\".\n        # Let's iterate through each person and give them N contacts.\n        for person in self.population:\n            for _ in range(contacts_per_person):\n                # Pick a random partner (can be self, model doesn't exclude it)\n                partner = random.choice(self.population)\n                # Attempt infection and collect IDs of those who *would* become infected\n                infected_ids = attempt_infection(person, partner, infection_prob)\n                newly_infected_ids_in_this_step.update(infected_ids)\n\n        # Now, apply the state changes from interactions *synchronously*\n        # Ensure we only infect those who are currently Susceptible\n        for person_id in newly_infected_ids_in_this_step:\n            person = self.population[person_id] # Assuming ID matches index\n            if person.health_status == 'Susceptible':\n                person.health_status = 'Infected'\n                person.days_infected = 0 # Newly infected start at day 0\n\n        # --- Phase 2: Status Updates ---\n        # Apply time-based status updates (e.g., recovery)\n        mean_infectious_duration = self.parameters['mean_infectious_duration']\n        for person in self.population:\n            person.update_status(mean_infectious_duration)\n\n        # --- Phase 3: Collect Metrics ---\n        self.metrics_collector.collect(step, self.population)\n\n\n    def run_simulation(self):\n        \"\"\"\n        Runs the simulation for the specified number of steps.\n        \"\"\"\n        simulation_steps = self.parameters['simulation_steps']\n        print(f\"Starting simulation for {simulation_steps} steps...\")\n\n        # Collect initial metrics (step 0)\n        self.metrics_collector.collect(0, self.population)\n\n        for step in range(1, simulation_steps + 1):\n            # print(f\"Running step {step}...\") # Uncomment for verbose output\n            self.run_step(step)\n\n        print(\"Simulation finished.\")\n        print(f\"Peak infected count: {self.metrics_collector.get_peak_infected()}\")\n\n\n    def get_results(self):\n        \"\"\"\n        Returns the simulation results (metrics) as a pandas DataFrame.\n        \"\"\"\n        return self.metrics_collector.get_dataframe()\n\n    def visualize_results(self, output_dir=\"results\"):\n        \"\"\"\n        Generates and saves plots of the simulation results.\n\n        Args:\n            output_dir (str): Directory to save the plots.\n        \"\"\"\n        df = self.get_results()\n\n        if df.empty:\n            print(\"No data to visualize.\")\n            return\n\n        # Ensure output directory exists\n        os.makedirs(output_dir, exist_ok=True)\n\n        plt.figure(figsize=(12, 6))\n        plt.plot(df['step'], df['susceptible_count'], label='Susceptible', color='blue')\n        plt.plot(df['step'], df['infected_count'], label='Infected', color='red')\n        plt.plot(df['step'], df['recovered_count'], label='Recovered', color='green')\n        plt.xlabel('Simulation Step (Days)')\n        plt.ylabel('Number of People')\n        plt.title('Epidemic Spread Over Time')\n        plt.legend()\n        plt.grid(True)\n        plt.tight_layout()\n        plot_path = os.path.join(output_dir, \"epidemic_curve.png\")\n        plt.savefig(plot_path)\n        print(f\"Epidemic curve saved to {plot_path}\")\n        # plt.show() # Uncomment if you want to display the plot immediately\n\n\n        plt.figure(figsize=(12, 6))\n        plt.plot(df['step'], df['total_infections'], label='Cumulative Infections', color='purple')\n        plt.xlabel('Simulation Step (Days)')\n        plt.ylabel('Cumulative Number of People')\n        plt.title('Cumulative Infections Over Time')\n        plt.legend()\n        plt.grid(True)\n        plt.tight_layout()\n        plot_path_cumulative = os.path.join(output_dir, \"cumulative_infections.png\")\n        plt.savefig(plot_path_cumulative)\n        print(f\"Cumulative infections plot saved to {plot_path_cumulative}\")\n        # plt.show() # Uncomment if you want to display the plot immediately\n\n\n        # Optional: Save metrics to CSV\n        csv_path = os.path.join(output_dir, \"simulation_metrics.csv\")\n        df.to_csv(csv_path, index=False)\n        print(f\"Simulation metrics saved to {csv_path}\")\n\n# --- Main Execution ---\n\nif __name__ == \"__main__\":\n    # Define simulation parameters based on the Model Plan\n    simulation_parameters = {\n        \"population_size\": 1000,\n        \"initial_infected_count\": 5,\n        \"infection_probability_per_contact\": 0.05,\n        \"mean_infectious_duration\": 10, # Corresponds to recovery after 10 days infected\n        \"contacts_per_person_per_step\": 5,\n        \"simulation_steps\": 200,\n        \"random_seed\": 42 # Using a fixed seed for reproducibility as suggested\n    }\n\n    # Create and run the simulation\n    sim = Simulation(simulation_parameters)\n    sim.run_simulation()\n\n    # Get and visualize results\n    results_df = sim.get_results()\n    print(\"\\nSimulation Results (first 5 steps):\")\n    print(results_df.head())\n    print(\"\\nSimulation Results (last 5 steps):\")\n    print(results_df.tail())\n\n    sim.visualize_results()\n\n    # Validation Check: Population Conservation\n    initial_pop = results_df['susceptible_count'][0] + results_df['infected_count'][0] + results_df['recovered_count'][0]\n    final_pop = results_df['susceptible_count'].iloc[-1] + results_df['infected_count'].iloc[-1] + results_df['recovered_count'].iloc[-1]\n    print(f\"\\nValidation Check: Population Conservation\")\n    print(f\"Initial Population Sum: {initial_pop}\")\n    print(f\"Final Population Sum: {final_pop}\")\n    if initial_pop == final_pop and initial_pop == simulation_parameters[\"population_size\"]:\n        print(\"Population conservation check passed.\")\n    else:\n        print(\"Population conservation check FAILED.\")\n\n    # Validation Check: Plausible Epidemic Curve (qualitative check based on visualization)\n    # This is hard to automate rigorously without defining \"plausible\".\n    # The generated plot should show S decreasing, I rising then falling, R increasing.\n    print(\"\\nValidation Check: Plausible Epidemic Curve\")\n    print(f\"Check the generated 'results/epidemic_curve.png' plot.\")\n    print(\"Expected: Susceptible decreases, Infected rises and falls (an epidemic curve), Recovered increases.\")\n\n    # Validation Check: Status Transition Logic\n    # This is primarily validated by inspecting the code logic for Person.update_status\n    # and attempt_infection. Automated checks would be complex (e.g., tracking individual\n    # agent histories). We rely on the code implementation matching the rules.\n    print(\"\\nValidation Check: Status Transition Logic\")\n    print(\"Logic is implemented in Person.update_status and interaction.attempt_infection.\")\n    print(\"Requires code review to verify correctness.\")\n\n    # Validation Check: Parameter Sensitivity\n    # Requires running the simulation with different parameters and comparing results.\n    # This is not part of a single execution but a process of analysis.\n    print(\"\\nValidation Check: Parameter Sensitivity\")\n    print(\"Requires running the simulation with different parameters (e.g., infection_probability_per_contact, contacts_per_person_per_step) and observing the effect on the epidemic curve.\")\n    print(\"This check is performed by the user running multiple simulations.\")",
  "code_summary": "Generated 391 lines of code containing 3 classes and 15 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "update_status"
    ]
  }
}