{
  "code": "import os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import KDTree\nfrom sklearn.mixture import GaussianMixture\nimport logging\nfrom typing import Tuple, List, Dict, Optional, Union\nimport random\n\n# Set up logging for error tracking and debugging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path handling setup\nPROJECT_ROOT = os.environ.get('PROJECT_ROOT', '.')\nDATA_PATH = os.environ.get('DATA_PATH', 'data')\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\nclass Environment:\n    \"\"\"\n    Manages the grid environment where agents move and interact.\n    \"\"\"\n    def __init__(self, dimensions: Tuple[int, int] = (50, 50)):\n        self.dimensions = dimensions\n        self.tree: Optional[KDTree] = None\n\n    def update_tree(self, positions: np.ndarray) -> None:\n        \"\"\"Updates the KDTree with the positions of all agents.\"\"\"\n        self.tree = KDTree(positions)\n\n    def get_agents_within_radius(self, position: np.ndarray, radius: float) -> List[int]:\n        \"\"\"Returns a list of agent indices within a certain radius of a given position.\"\"\"\n        if self.tree is None:\n            return []\n        return self.tree.query_ball_point(position, r=radius)\n\nclass Person:\n    \"\"\"\n    Represents an individual in the simulation with specific attributes and behaviors.\n    \"\"\"\n    def __init__(self, infected_status: str, transmission_probability: float, recovery_chance: float,\n                 interaction_rate: float, interaction_radius: float, infection_duration_range: Tuple[int, int],\n                 step_size: float = 1.0):\n        self.infected_status = infected_status\n        self.transmission_probability = transmission_probability\n        self.recovery_chance = recovery_chance\n        self.interaction_rate = interaction_rate\n        self.interaction_radius = interaction_radius\n        self.position = np.array([0.0, 0.0])\n        self.infection_duration = 0\n        self.infection_duration_range = infection_duration_range\n        self.immune_status = 'not_immune'\n        self.infection_time = 0\n        self.step_size = step_size\n\n    def move(self) -> None:\n        \"\"\"Moves the person randomly within the environment.\"\"\"\n        step = np.random.uniform(-self.step_size, self.step_size, 2)\n        self.position = np.clip(self.position + step, 0, 50)\n\n    def interact(self, other: 'Person') -> None:\n        \"\"\"Handles interaction between this person and another, potentially infecting them.\"\"\"\n        if self.infected_status == 'infected' and other.infected_status == 'susceptible':\n            self.infect(other)\n\n    def infect(self, other: 'Person') -> None:\n        \"\"\"Attempts to infect another person based on transmission probability.\"\"\"\n        if other.infected_status == 'susceptible':\n            environment_factor = np.random.uniform(0.8, 1.2)\n            probability = min(max(np.random.normal(self.transmission_probability, 0.02), 0), 1)\n            if random.random() < probability * environment_factor:\n                other.get_infected()\n\n    def get_infected(self) -> None:\n        \"\"\"Sets the person's status to infected and initializes infection duration.\"\"\"\n        self.infected_status = 'infected'\n        self.infection_duration = random.randint(*self.infection_duration_range)\n        self.infection_time = 0\n\n    def recover(self) -> None:\n        \"\"\"Handles the recovery process of an infected person.\"\"\"\n        if self.infected_status == 'infected':\n            self.infection_duration -= 1\n            self.infection_time += 1\n            if self.infection_duration <= 0:\n                if random.random() < self.recovery_chance:\n                    self.infected_status = 'recovered'\n                    self.update_immune_status()\n\n    def update_immune_status(self) -> None:\n        \"\"\"Updates the immune status of the person.\"\"\"\n        self.immune_status = 'immune'\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation of the epidemic spread, including evaluation and visualization of results.\n    \"\"\"\n    def __init__(self, population_size: int, initial_infected: int, transmission_probability: float,\n                 recovery_chance: float, recovery_time: int = 14, step_size: float = 1.0):\n        if population_size <= 0:\n            raise ValueError(\"Population size must be greater than zero.\")\n        if initial_infected < 0 or initial_infected > population_size:\n            raise ValueError(\"Initial infected count must be between 0 and the population size.\")\n\n        random.seed(42)\n        self.people: List[Person] = []\n        self.transmission_probability = transmission_probability\n        self.recovery_chance = recovery_chance\n        self.time_step = 0\n        self.infection_counts = []\n        self.environment = Environment()\n\n        positions = self.generate_clustered_positions(population_size)\n\n        for i in range(population_size):\n            infected_status = 'susceptible'\n            infection_chance = random.uniform(0.2, 0.5)\n            interaction_rate = random.uniform(0.1, 0.3)\n            interaction_radius = random.uniform(5.0, 10.0)\n            infection_duration_range = (recovery_time - 5, recovery_time + 5)\n            person = Person(infected_status, transmission_probability, recovery_chance, interaction_rate, interaction_radius,\n                            infection_duration_range, step_size)\n            person.position = positions[i]\n            self.people.append(person)\n\n        initial_infected_indices = random.sample(range(population_size), initial_infected)\n        for idx in initial_infected_indices:\n            self.people[idx].infected_status = 'infected'\n            self.people[idx].infection_duration = random.randint(*self.people[idx].infection_duration_range)\n\n    def generate_clustered_positions(self, population_size: int) -> np.ndarray:\n        \"\"\"\n        Generates clustered positions for the population using Gaussian Mixture Model.\n\n        :param population_size: Number of positions to generate\n        :return: numpy array of positions\n        \"\"\"\n        samples_to_generate = max(100, 2 * population_size)\n        gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\n        gmm.fit(np.random.rand(samples_to_generate, 2))\n        positions = gmm.sample(population_size)[0]\n        return np.clip(positions * 50, 0, 50)\n\n    def run(self, days: int) -> None:\n        \"\"\"\n        Runs the simulation for a specified number of days.\n        \"\"\"\n        for _ in range(days):\n            self.time_step += 1\n\n            for person in self.people:\n                person.move()\n\n            positions = np.array([person.position for person in self.people])\n            self.environment.update_tree(positions)\n\n            for person in self.people:\n                if person.infected_status == 'infected':\n                    indices = self.environment.get_agents_within_radius(person.position, person.interaction_radius)\n                    for idx in indices:\n                        other = self.people[idx]\n                        if person != other:\n                            person.interact(other)\n                person.recover()\n\n            infected_count = sum(p.infected_status == 'infected' for p in self.people)\n            self.infection_counts.append(infected_count)\n\n    def evaluate(self) -> Dict[str, Union[int, float]]:\n        \"\"\"\n        Evaluates the simulation results and returns key metrics.\n\n        :return: Dictionary of metrics\n        \"\"\"\n        peak_infection_day = self.infection_counts.index(max(self.infection_counts)) if self.infection_counts else -1\n        steady_state_infection = self.check_steady_state_infection()\n        metrics = {\n            'infection_rate': sum(1 for p in self.people if p.infected_status == 'infected') / len(self.people),\n            'recovery_rate': sum(1 for p in self.people if p.infected_status == 'recovered') / len(self.people),\n            'peak_infection_day': peak_infection_day,\n            'steady_state_infection': steady_state_infection\n        }\n        logging.info(f\"Steady state infection: {steady_state_infection}\")\n        return metrics\n\n    def check_steady_state_infection(self, threshold: float = 0.01) -> bool:\n        \"\"\"\n        Checks if the infection count has reached a steady state.\n\n        :param threshold: Threshold for detecting steady state\n        :return: Boolean indicating if steady state is achieved\n        \"\"\"\n        if len(self.infection_counts) < 6:\n            return False\n        recent_changes = np.abs(np.diff(self.infection_counts[-5:]))\n        return np.all(recent_changes < threshold * np.array(self.infection_counts[-5:-1]))\n\n    def visualize(self) -> None:\n        \"\"\"\n        Visualizes the simulation results.\n        \"\"\"\n        statuses = [p.infected_status for p in self.people]\n        labels, counts = np.unique(statuses, return_counts=True)\n        plt.figure(figsize=(10, 5))\n        plt.subplot(1, 2, 1)\n        plt.bar(labels, counts)\n        plt.title('Simulation Results')\n        plt.xlabel('Health Status')\n        plt.ylabel('Count')\n\n        plt.subplot(1, 2, 2)\n        plt.plot(self.infection_counts, label='Infected')\n        plt.title('Infection Over Time')\n        plt.xlabel('Days')\n        plt.ylabel('Number of Infected People')\n        plt.tight_layout()\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"\n        Saves the simulation results to a CSV file.\n\n        :param filename: The path where to save the file\n        \"\"\"\n        directory = os.path.dirname(filename)\n        if directory and not os.path.exists(directory):\n            os.makedirs(directory, exist_ok=True)\n\n        if not filename:\n            logging.error('Filename is empty.')\n            return\n\n        try:\n            with open(filename, 'w') as file:\n                file.write('infected_status,infection_chance,recovery_chance,interaction_rate\\n')\n                for person in self.people:\n                    file.write(f\"{person.infected_status},{person.transmission_probability},{person.recovery_chance},{person.interaction_rate}\\n\")\n            logging.info(f'Successfully saved results to {filename}')\n        except PermissionError as e:\n            logging.error(f'Permission error while writing the file: {e}')\n        except IOError as e:\n            logging.error(f'File I/O error: {e}')\n        except Exception as e:\n            logging.error(f'An unexpected error occurred while writing to the file: {e}')\n\n    def reset(self) -> None:\n        \"\"\"\n        Resets or reinitializes the simulation, allowing repeated runs without re-instantiating the class.\n        \"\"\"\n        self.__init__(len(self.people), sum(p.infected_status == 'infected' for p in self.people), \n                      self.transmission_probability, self.recovery_chance)\n        self.environment = Environment()\n\ndef main():\n    \"\"\"\n    Main function to run the simulation.\n    \"\"\"\n    population_size = 1000\n    initial_infected = int(population_size * 0.05)\n    transmission_probability = 0.03\n    recovery_chance = 0.9\n    recovery_time = 14\n\n    sim = Simulation(population_size, initial_infected, transmission_probability, recovery_chance, recovery_time)\n    sim.run(100)\n    results = sim.evaluate()\n    logging.info(f\"Simulation results: {results}\")\n    sim.visualize()\n    sim.save_results('simulation_results.txt')\n\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 272 lines of code containing 3 classes and 19 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "get_infected",
      "recover"
    ]
  }
}