{
  "code": "import os\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import KDTree\nfrom sklearn.mixture import GaussianMixture\nimport logging\n\n# Set up logging for error tracking\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path handling setup\nPROJECT_ROOT = os.environ.get(\"PROJECT_ROOT\", \".\")\nDATA_PATH = os.environ.get(\"DATA_PATH\", \"data\")\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\nclass Person:\n    \"\"\"\n    Represents an individual in the simulation with specific attributes and behaviors.\n    \"\"\"\n    def __init__(self, health_status: str, infection_chance: float, recovery_chance: float, interaction_rate: float, interaction_radius: float, infection_duration_range: tuple):\n        self.health_status = health_status\n        self.infection_chance = infection_chance\n        self.recovery_chance = recovery_chance\n        self.interaction_rate = interaction_rate\n        self.interaction_radius = interaction_radius\n        self.position = None\n        self.infection_duration = 0\n        self.infection_duration_range = infection_duration_range\n        self.immune_status = \"not_immune\"\n\n    def random_walk(self) -> None:\n        \"\"\"\n        Simulates the random movement of the person within the environment.\n        \"\"\"\n        step = np.random.uniform(-1, 1, 2)\n        self.position = np.clip(self.position + step, 0, 100)\n\n    def interact(self, other: 'Person') -> None:\n        \"\"\"\n        Defines interaction between people that may lead to infection.\n        \"\"\"\n        if self.health_status == \"infected\" and other.health_status == \"susceptible\":\n            self.infect(other)\n\n    def infect(self, other: 'Person') -> None:\n        \"\"\"\n        Attempts to infect another person based on infection chance and environmental factors.\n        \"\"\"\n        environment_factor = np.random.uniform(0.8, 1.2)\n        if random.random() < self.infection_chance * environment_factor:\n            other.health_status = \"infected\"\n            other.infection_duration = random.randint(*self.infection_duration_range)\n\n    def recover(self) -> None:\n        \"\"\"\n        Simulates the recovery process of an infected person.\n        \"\"\"\n        if self.health_status == \"infected\":\n            self.infection_duration -= 1\n            if self.infection_duration <= 0:\n                if random.random() < self.recovery_chance:\n                    self.health_status = \"recovered\"\n                    self.immune_status = \"immune\"\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation of the epidemic spread.\n    \"\"\"\n    def __init__(self, population_size: int, initial_infected: int, transmission_probability: float, recovery_chance: float):\n        \"\"\"\n        Initializes the simulation with a specified population size, number of initially infected people,\n        transmission probability, and recovery chance.\n        \"\"\"\n        random.seed(42)\n        self.people = []\n        self.transmission_probability = transmission_probability\n        self.recovery_chance = recovery_chance\n        self.time_step = 0\n        self.infection_counts = []\n\n        # Use Gaussian Mixture Model for initial clustering of agents\n        gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\n        positions = gmm.sample(population_size)[0]\n        \n        # Ensure positions have the correct shape\n        assert positions.shape == (population_size, 2), \"Position array has an incorrect shape.\"\n\n        positions = positions * 50 + 50\n\n        for i in range(population_size):\n            health_status = \"susceptible\"\n            infection_chance = random.uniform(0.05, 0.15)\n            interaction_rate = random.uniform(0.1, 0.3)\n            interaction_radius = 1.0\n            infection_duration_range = (5, 15)\n            person = Person(health_status, infection_chance, recovery_chance, interaction_rate, interaction_radius, infection_duration_range)\n            person.position = positions[i]\n            self.people.append(person)\n\n        for person in random.sample(self.people, initial_infected):\n            person.health_status = \"infected\"\n            person.infection_duration = random.randint(5, 15)\n\n    def run(self, days: int) -> None:\n        \"\"\"\n        Executes the simulation over a specified number of days.\n        \"\"\"\n        for _ in range(days):\n            self.time_step += 1\n\n            for person in self.people:\n                person.random_walk()\n\n            positions = np.array([person.position for person in self.people])\n            tree = KDTree(positions)\n\n            for person in self.people:\n                if person.health_status == \"infected\":\n                    indices = tree.query_ball_point(person.position, r=person.interaction_radius)\n                    for idx in indices:\n                        other = self.people[idx]\n                        if person != other:\n                            person.interact(other)\n                person.recover()\n\n            infected_count = sum(p.health_status == \"infected\" for p in self.people)\n            self.infection_counts.append(infected_count)\n\n    def evaluate(self) -> dict:\n        \"\"\"\n        Evaluates the simulation metrics.\n        \"\"\"\n        peak_infection_day = self.infection_counts.index(max(self.infection_counts)) if self.infection_counts else -1\n        metrics = {\n            \"infection_rate\": sum(1 for p in self.people if p.health_status == \"infected\") / len(self.people),\n            \"recovery_rate\": sum(1 for p in self.people if p.health_status == \"recovered\") / len(self.people),\n            \"peak_infection_day\": peak_infection_day\n        }\n        return metrics\n\n    def visualize(self) -> None:\n        \"\"\"\n        Visualizes the results of the simulation.\n        \n        Displays a bar chart of the health status distribution of the population at the end of the simulation.\n        \"\"\"\n        statuses = [p.health_status for p in self.people]\n        labels, counts = np.unique(statuses, return_counts=True)\n        plt.bar(labels, counts)\n        plt.title(\"Simulation Results\")\n        plt.xlabel(\"Health Status\")\n        plt.ylabel(\"Count\")\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"\n        Saves the simulation results to a file.\n        \"\"\"\n        try:\n            with open(filename, \"w\") as file:\n                file.write(\"health_status,infection_chance,recovery_chance,interaction_rate\\n\")\n                for person in self.people:\n                    file.write(f\"{person.health_status},{person.infection_chance},{person.recovery_chance},{person.interaction_rate}\\n\")\n        except IOError as e:\n            logging.error(f\"File I/O error: {e}\")\n            raise\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred while writing to the file: {e}\")\n            raise\n\ndef main() -> None:\n    sim = Simulation(population_size=1000, initial_infected=1, transmission_probability=0.1, recovery_chance=0.05)\n    sim.run(days=100)\n    sim.visualize()\n    sim.save_results(\"results.csv\")\n\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 180 lines of code containing 2 classes and 11 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "infect"
    ]
  }
}