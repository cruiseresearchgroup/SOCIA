{
  "code": "import os\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import KDTree\nfrom sklearn.mixture import GaussianMixture\nimport logging\nfrom typing import Tuple, List, Dict\n\n# Set up logging for error tracking and debugging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path handling setup\nPROJECT_ROOT = os.environ.get('PROJECT_ROOT', '.')\nDATA_PATH = os.environ.get('DATA_PATH', 'data')\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\nclass Environment:\n    \"\"\"\n    Manages the grid environment where agents move and interact.\n    \"\"\"\n    def __init__(self, dimensions: Tuple[int, int] = (50, 50)):\n        self.dimensions = dimensions\n        self.tree = None\n\n    def update_tree(self, positions: np.ndarray) -> None:\n        \"\"\"\n        Updates the KDTree with new positions.\n\n        :param positions: Array of positions for all agents.\n        \"\"\"\n        self.tree = KDTree(positions)\n    \n    def get_agents_in_radius(self, position: np.ndarray, radius: float) -> List[int]:\n        \"\"\"\n        Retrieves indices of agents within a specified radius from a position.\n\n        :param position: Position to query around.\n        :param radius: Radius within which to look for other agents.\n        :return: List of indices of agents within the radius.\n        \"\"\"\n        if self.tree is None:\n            return []\n        return self.tree.query_ball_point(position, r=radius)\n\n\nclass Person:\n    \"\"\"\n    Represents an individual in the simulation with specific attributes and behaviors.\n    \"\"\"\n    def __init__(self, infected_status: str, infection_chance: float, recovery_chance: float, interaction_rate: float,\n                 interaction_radius: float, infection_duration_range: Tuple[int, int], transmission_probability: float,\n                 step_size: float = 1.0):\n        self.infected_status = infected_status\n        self.infection_chance = infection_chance\n        self.recovery_chance = recovery_chance\n        self.interaction_rate = interaction_rate\n        self.interaction_radius = interaction_radius\n        self.position = np.array([0.0, 0.0])  # Initialized to a valid numpy array\n        self.infection_duration = 0\n        self.infection_duration_range = infection_duration_range\n        self.immune_status = 'not_immune'\n        self.transmission_probability = transmission_probability\n        self.infection_time = 0  # Added attribute to track infection time\n        self.step_size = step_size\n\n    def random_walk(self) -> None:\n        \"\"\"\n        Simulates the random movement of the person within the environment.\n        \"\"\"\n        step = np.random.uniform(-self.step_size, self.step_size, 2)\n        self.position = np.clip(self.position + step, 0, 50)  # Clipped to environment grid\n\n    def interact(self, other: 'Person') -> None:\n        \"\"\"\n        Defines interaction between people that may lead to infection.\n\n        :param other: The other person with whom this person interacts.\n        \"\"\"\n        if self.infected_status == 'infected' and other.infected_status == 'susceptible':\n            self.become_infected(other)\n\n    def become_infected(self, other: 'Person') -> None:\n        \"\"\"\n        Attempts to infect another person based on infection chance and environmental factors.\n\n        :param other: The person to potentially infect.\n        \"\"\"\n        environment_factor = np.random.uniform(0.8, 1.2)\n        if random.random() < self.transmission_probability * self.infection_chance * environment_factor:\n            other.infected_status = 'infected'\n            other.infection_duration = random.randint(*self.infection_duration_range)\n            other.infection_time = 0  # Reset infection time upon infection\n\n    def recover(self) -> None:\n        \"\"\"\n        Simulates the recovery process of an infected person.\n        \"\"\"\n        if self.infected_status == 'infected':\n            self.infection_duration -= 1\n            self.infection_time += 1  # Track infection time\n            if self.infection_duration <= 0:\n                if random.random() < self.recovery_chance:\n                    self.infected_status = 'recovered'\n                    self.immune_status = 'immune'\n\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation of the epidemic spread, including evaluation and visualization of results.\n    \"\"\"\n    def __init__(self, population_size: int, initial_infected: int, transmission_probability: float,\n                 recovery_chance: float, recovery_time: int = 14, step_size: float = 1.0):\n        \"\"\"\n        Initializes the simulation with a specified population size, number of initially infected people,\n        transmission probability, and recovery chance.\n\n        :param population_size: The total number of people in the simulation.\n        :param initial_infected: The number of initially infected people.\n        :param transmission_probability: The probability of transmission per interaction.\n        :param recovery_chance: The chance of recovery after the infection duration.\n        :param recovery_time: The average time for recovery.\n        :param step_size: The movement step size for each person.\n        \"\"\"\n        if population_size <= 0:\n            raise ValueError(\"Population size must be greater than zero.\")\n        if initial_infected < 0 or initial_infected > population_size:\n            raise ValueError(\"Initial infected count must be between 0 and the population size.\")\n        \n        random.seed(42)\n        self.people: List[Person] = []\n        self.transmission_probability = transmission_probability\n        self.recovery_chance = recovery_chance\n        self.time_step = 0\n        self.infection_counts = []\n        self.environment = Environment()\n\n        # Use Gaussian Mixture Model for initial clustering of agents\n        gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\n\n        # Fit the GaussianMixture model with random data before sampling\n        gmm.fit(np.random.rand(100, 2))\n        positions: np.ndarray = gmm.sample(population_size)[0]\n\n        # Ensure positions are initialized within the grid bounds\n        if positions.shape != (population_size, 2):\n            raise RuntimeError(\"Position array has an incorrect shape.\")\n\n        positions = positions * 50\n\n        for i in range(population_size):\n            infected_status = 'susceptible'\n            infection_chance = random.uniform(0.05, 0.15)\n            interaction_rate = random.uniform(0.1, 0.3)\n            interaction_radius = 1.0\n            infection_duration_range = (recovery_time - 5, recovery_time + 5)  # Set realistic infection duration range based on recovery time\n            person = Person(infected_status, infection_chance, recovery_chance, interaction_rate, interaction_radius,\n                            infection_duration_range, transmission_probability, step_size)\n            person.position = positions[i]\n            self.people.append(person)\n\n        # Random selection for initial infections\n        for person in random.sample(self.people, initial_infected):\n            person.infected_status = 'infected'\n            person.infection_duration = random.randint(5, 15)\n\n    def run(self, days: int) -> None:\n        \"\"\"\n        Executes the simulation over a specified number of days.\n\n        :param days: The number of days to run the simulation.\n        \"\"\"\n        for _ in range(days):\n            self.time_step += 1\n\n            for person in self.people:\n                person.random_walk()\n\n            positions = np.array([person.position for person in self.people])\n            self.environment.update_tree(positions)\n\n            for person in self.people:\n                if person.infected_status == 'infected':\n                    indices = self.environment.get_agents_in_radius(person.position, person.interaction_radius)\n                    for idx in indices:\n                        other = self.people[idx]\n                        if person != other:\n                            person.interact(other)\n                person.recover()\n\n            infected_count = sum(p.infected_status == 'infected' for p in self.people)\n            self.infection_counts.append(infected_count)\n\n    def evaluate(self) -> Dict[str, float]:\n        \"\"\"\n        Evaluates the simulation metrics.\n\n        :return: A dictionary containing infection_rate, recovery_rate, and peak_infection_day.\n        \"\"\"\n        peak_infection_day = self.infection_counts.index(max(self.infection_counts)) if self.infection_counts else -1\n        metrics = {\n            'infection_rate': sum(1 for p in self.people if p.infected_status == 'infected') / len(self.people),\n            'recovery_rate': sum(1 for p in self.people if p.infected_status == 'recovered') / len(self.people),\n            'peak_infection_day': peak_infection_day\n        }\n        return metrics\n\n    def visualize(self) -> None:\n        \"\"\"\n        Visualizes the results of the simulation.\n\n        Displays a bar chart of the health status distribution of the population at the end of the simulation\n        and a line graph showing the number of infections over time.\n        \"\"\"\n        # Visualize health status distribution\n        statuses = [p.infected_status for p in self.people]\n        labels, counts = np.unique(statuses, return_counts=True)\n        plt.figure(figsize=(10, 5))\n        plt.subplot(1, 2, 1)\n        plt.bar(labels, counts)\n        plt.title('Simulation Results')\n        plt.xlabel('Health Status')\n        plt.ylabel('Count')\n        \n        # Visualize infection curve over time\n        plt.subplot(1, 2, 2)\n        plt.plot(self.infection_counts, label='Infected')\n        plt.title('Infection Over Time')\n        plt.xlabel('Days')\n        plt.ylabel('Number of Infected People')\n        plt.tight_layout()\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"\n        Saves the simulation results to a file.\n\n        :param filename: The name of the file to save the results.\n        \"\"\"\n        if not filename:\n            logging.error('Invalid filename: Filename cannot be empty.')\n            return\n        try:\n            # Ensure the directory exists before writing the file\n            if not os.path.exists(os.path.dirname(filename)):\n                os.makedirs(os.path.dirname(filename), exist_ok=True)\n            with open(filename, 'w') as file:\n                file.write('infected_status,infection_chance,recovery_chance,interaction_rate\\n')\n                for person in self.people:\n                    file.write(f\"{person.infected_status},{person.infection_chance},{person.recovery_chance},{person.interaction_rate}\\n\")\n        except PermissionError as e:\n            logging.error(f'Permission error while writing the file: {e}')\n        except IOError as e:\n            logging.error(f'File I/O error: {e}')\n        except Exception as e:\n            logging.error(f'An unexpected error occurred while writing to the file: {e}')\n\n    def reset(self) -> None:\n        \"\"\"\n        Resets or reinitializes the simulation, allowing repeated runs without re-instantiating the class.\n        \"\"\"\n        self.__init__(len(self.people), sum(p.infected_status == 'infected' for p in self.people), self.transmission_probability, self.recovery_chance)\n\n\ndef main() -> None:\n    \"\"\"\n    Initializes and runs the epidemic simulation, then visualizes and saves the results.\n    \"\"\"\n    sim = Simulation(population_size=1000, initial_infected=1, transmission_probability=0.1, recovery_chance=0.05)\n    sim.run(days=100)\n    sim.visualize()\n    sim.save_results(os.path.join(DATA_DIR, 'results.csv'))\n\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 276 lines of code containing 3 classes and 15 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "infect",
      "recover"
    ]
  }
}