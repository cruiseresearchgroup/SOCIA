{
  "code": "import os\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import KDTree\n\n# Path handling setup\nPROJECT_ROOT = os.environ.get(\"PROJECT_ROOT\", \".\")\nDATA_PATH = os.environ.get(\"DATA_PATH\", \"data\")\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\nclass Person:\n    \"\"\"\n    Represents an individual in the simulation with specific attributes and behaviors.\n    \"\"\"\n    def __init__(self, health_status: str, infection_probability: float, recovery_rate: float, interaction_rate: float):\n        self.health_status = health_status\n        self.infection_probability = infection_probability\n        self.recovery_rate = recovery_rate\n        self.interaction_rate = interaction_rate\n        self.position = np.random.uniform(0, 100, 2)  # Random initial position\n\n    def random_walk(self) -> None:\n        \"\"\"\n        Simulates the random movement of the person within the environment.\n        \"\"\"\n        step = np.random.uniform(-1, 1, 2)  # Random step\n        self.position = np.clip(self.position + step, 0, 100)  # Ensure within bounds\n\n    def interact(self, other: 'Person') -> bool:\n        \"\"\"\n        Defines interaction between people that may lead to infection.\n        \"\"\"\n        distance = np.linalg.norm(self.position - other.position)\n        if distance < 1.0:  # Defined interaction radius\n            return True\n        return False\n\n    def infect(self, other: 'Person', transmission_probability: float) -> None:\n        \"\"\"\n        Simulates the infection process when an infected person interacts with a susceptible person.\n        \"\"\"\n        if self.health_status == \"infected\" and other.health_status == \"susceptible\":\n            if random.random() < self.infection_probability * transmission_probability:\n                other.health_status = \"infected\"\n\n    def recover(self) -> None:\n        \"\"\"\n        Simulates the recovery process of an infected person.\n        \"\"\"\n        if self.health_status == \"infected\":\n            if random.random() < self.recovery_rate:\n                self.health_status = \"recovered\"\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation of the epidemic spread.\n    \"\"\"\n    def __init__(self, population_size: int, initial_infected: int, transmission_probability: float, recovery_rate: float):\n        \"\"\"\n        Initializes the simulation with a specified population size, number of initially infected people,\n        transmission probability, and recovery rate.\n\n        Parameters:\n        - population_size: The total number of people in the simulation.\n        - initial_infected: The initial number of infected individuals.\n        - transmission_probability: The probability that a susceptible person becomes infected when interacting with an infected person.\n        - recovery_rate: The probability that an infected person recovers in a given time step.\n        \"\"\"\n        random.seed(42)  # Ensures reproducibility\n        self.people = []\n        for _ in range(population_size):\n            health_status = \"susceptible\"\n            infection_probability = random.uniform(0.05, 0.15)\n            interaction_rate = random.uniform(0.1, 0.3)\n            person = Person(health_status, infection_probability, recovery_rate, interaction_rate)\n            self.people.append(person)\n        \n        # Infect the initial set of people\n        for person in random.sample(self.people, initial_infected):\n            person.health_status = \"infected\"\n\n        self.transmission_probability = transmission_probability\n        self.recovery_rate = recovery_rate\n        self.time_step = 0\n        self.infection_counts = []\n\n    def run(self, days: int) -> None:\n        \"\"\"\n        Executes the simulation over a specified number of days.\n        \"\"\"\n        for _ in range(days):\n            self.time_step += 1\n\n            # Move all people\n            for person in self.people:\n                person.random_walk()\n\n            # Build a spatial index\n            positions = np.array([person.position for person in self.people])\n            tree = KDTree(positions)\n\n            # Check for interactions and infections\n            for person in self.people:\n                if person.health_status == \"infected\":\n                    indices = tree.query_ball_point(person.position, r=1.0)\n                    for idx in indices:\n                        other = self.people[idx]\n                        if person != other and person.interact(other):\n                            person.infect(other, self.transmission_probability)\n                person.recover()\n\n            # Track infection counts\n            infected_count = sum(p.health_status == \"infected\" for p in self.people)\n            self.infection_counts.append(infected_count)\n\n    def evaluate(self) -> dict:\n        \"\"\"\n        Evaluates the simulation metrics.\n        \"\"\"\n        peak_infection_day = self.infection_counts.index(max(self.infection_counts)) if self.infection_counts else -1\n        metrics = {\n            \"infection_rate\": sum(1 for p in self.people if p.health_status == \"infected\") / len(self.people),\n            \"recovery_rate\": sum(1 for p in self.people if p.health_status == \"recovered\") / len(self.people),\n            \"peak_infection_day\": peak_infection_day\n        }\n        return metrics\n\n    def visualize(self) -> None:\n        \"\"\"\n        Visualizes the results of the simulation.\n        \"\"\"\n        statuses = [p.health_status for p in self.people]\n        labels, counts = np.unique(statuses, return_counts=True)\n        plt.bar(labels, counts)\n        plt.title(\"Simulation Results\")\n        plt.xlabel(\"Health Status\")\n        plt.ylabel(\"Count\")\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"\n        Saves the simulation results to a file.\n        \"\"\"\n        try:\n            with open(filename, \"w\") as file:\n                file.write(\"health_status,infection_probability,recovery_rate,interaction_rate\\n\")\n                for person in self.people:\n                    file.write(f\"{person.health_status},{person.infection_probability},{person.recovery_rate},{person.interaction_rate}\\n\")\n        except (PermissionError, OSError) as e:\n            print(f\"An error occurred while writing to the file: {e}\")\n\ndef main() -> None:\n    sim = Simulation(population_size=1000, initial_infected=1, transmission_probability=0.1, recovery_rate=0.05)\n    sim.run(days=100)\n    sim.visualize()\n    sim.save_results(\"results.csv\")\n\nmain()",
  "code_summary": "Generated 159 lines of code containing 2 classes and 11 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "infect",
      "recover"
    ]
  }
}