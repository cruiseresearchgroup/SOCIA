{
  "code": "import os\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import KDTree\nfrom sklearn.mixture import GaussianMixture\nimport logging\nfrom typing import Tuple, List, Dict\n\n# Set up logging for error tracking and debugging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Path handling setup\nPROJECT_ROOT = os.environ.get('PROJECT_ROOT', '.')\nDATA_PATH = os.environ.get('DATA_PATH', 'data')\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\nclass Environment:\n    \"\"\"\n    Manages the grid environment where agents move and interact.\n    \"\"\"\n    def __init__(self, dimensions: Tuple[int, int] = (100, 100)):\n        \"\"\"\n        Initializes the environment with a given dimension.\n        \n        :param dimensions: Tuple representing the size of the grid.\n        \"\"\"\n        self.dimensions = dimensions\n        self.tree = None\n\n    def update_tree(self, positions: np.ndarray) -> None:\n        \"\"\"\n        Updates the KDTree with new positions.\n\n        :param positions: Array of positions for all agents.\n        \"\"\"\n        self.tree = KDTree(positions)\n\n    def get_agents_within_radius(self, position: np.ndarray, radius: float) -> List[int]:\n        \"\"\"\n        Retrieves indices of agents within a specified radius from a position.\n\n        :param position: Position to query around.\n        :param radius: Radius within which to look for other agents.\n        :return: List of indices of agents within the radius.\n        \"\"\"\n        if self.tree is None:\n            return []\n        return self.tree.query_ball_point(position, r=radius)\n\nclass Person:\n    \"\"\"\n    Represents an individual in the simulation with specific attributes and behaviors.\n    \"\"\"\n    def __init__(self, infected_status: str, infection_chance: float, recovery_chance: float, interaction_rate: float,\n                 interaction_radius: float, infection_duration_range: Tuple[int, int], transmission_probability: float,\n                 step_size: float = 1.0):\n        \"\"\"\n        Initializes a person with attributes related to infection and movement.\n\n        :param infected_status: Status of infection ('infected', 'susceptible', or 'recovered').\n        :param infection_chance: Chance of getting infected during interaction.\n        :param recovery_chance: Chance of recovery after the infection duration.\n        :param interaction_rate: Rate at which interactions occur.\n        :param interaction_radius: Radius within which interactions happen.\n        :param infection_duration_range: Range of infection duration.\n        :param transmission_probability: Probability of transmitting the infection.\n        :param step_size: Movement step size for random walk.\n        \"\"\"\n        self.infected_status = infected_status\n        self.infection_chance = infection_chance\n        self.recovery_chance = recovery_chance\n        self.interaction_rate = interaction_rate\n        self.interaction_radius = interaction_radius\n        self.position = np.array([0.0, 0.0])  # Initialized to a valid numpy array\n        self.infection_duration = 0\n        self.infection_duration_range = infection_duration_range\n        self.immune_status = 'not_immune'\n        self.transmission_probability = transmission_probability\n        self.infection_time = 0  # Added attribute to track infection time\n        self.step_size = step_size\n\n    def move(self) -> None:\n        \"\"\"\n        Simulates the random movement of the person within the environment.\n        \"\"\"\n        step = np.random.uniform(-self.step_size, self.step_size, 2)\n        self.position = np.clip(self.position + step, 0, 100)  # Clipped to environment grid\n\n    def interact(self, other: 'Person') -> None:\n        \"\"\"\n        Defines interaction between people that may lead to infection.\n\n        :param other: The other person with whom this person interacts.\n        \"\"\"\n        if self.infected_status == 'infected' and other.infected_status == 'susceptible':\n            self.infect(other)\n\n    def infect(self, other: 'Person') -> None:\n        \"\"\"\n        Attempts to infect another person based on infection chance and environmental factors.\n\n        :param other: The person to potentially infect.\n        \"\"\"\n        environment_factor = np.random.uniform(0.8, 1.2)\n        if random.random() < np.random.normal(self.transmission_probability, 0.02) * self.infection_chance * environment_factor:\n            other.infected_status = 'infected'\n            other.infection_duration = random.randint(*self.infection_duration_range)\n            other.infection_time = 0  # Reset infection time upon infection\n\n    def recover(self) -> None:\n        \"\"\"\n        Simulates the recovery process of an infected person.\n        \"\"\"\n        if self.infected_status == 'infected':\n            self.infection_duration -= 1\n            self.infection_time += 1  # Track infection time\n            if self.infection_duration <= 0:\n                if random.random() < self.recovery_chance:\n                    self.infected_status = 'recovered'\n                    self.immune_status = 'immune'\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation of the epidemic spread, including evaluation and visualization of results.\n    \"\"\"\n    def __init__(self, population_size: int, initial_infected: int, transmission_probability: float,\n                 recovery_chance: float, recovery_time: int = 14, step_size: float = 1.0):\n        \"\"\"\n        Initializes the simulation with a specified population size, number of initially infected people,\n        transmission probability, and recovery chance.\n\n        :param population_size: The total number of people in the simulation.\n        :param initial_infected: The number of initially infected people.\n        :param transmission_probability: The probability of transmission per interaction.\n        :param recovery_chance: The chance of recovery after the infection duration.\n        :param recovery_time: The average time for recovery.\n        :param step_size: The movement step size for each person.\n        \"\"\"\n        if population_size <= 0:\n            raise ValueError(\"Population size must be greater than zero.\")\n        if initial_infected < 0 or initial_infected > population_size:\n            raise ValueError(\"Initial infected count must be between 0 and the population size.\")\n        \n        random.seed(42)\n        self.people: List[Person] = []\n        self.transmission_probability = transmission_probability\n        self.recovery_chance = recovery_chance\n        self.time_step = 0\n        self.infection_counts = []\n        self.environment = Environment()\n\n        positions = self.generate_clustered_positions(population_size)\n\n        for i in range(population_size):\n            infected_status = 'susceptible'\n            infection_chance = random.uniform(0.05, 0.15)\n            interaction_rate = random.uniform(0.1, 0.3)\n            interaction_radius = 1.0\n            infection_duration_range = (recovery_time - 5, recovery_time + 5)\n            person = Person(infected_status, infection_chance, recovery_chance, interaction_rate, interaction_radius,\n                            infection_duration_range, transmission_probability, step_size)\n            person.position = positions[i]\n            self.people.append(person)\n\n        initial_infected_indices = np.random.choice(population_size, initial_infected, replace=False)\n        for idx in initial_infected_indices:\n            self.people[idx].infected_status = 'infected'\n            self.people[idx].infection_duration = random.randint(5, 15)\n\n    def generate_clustered_positions(self, population_size: int) -> np.ndarray:\n        \"\"\"\n        Generates initial positions for the population using a clustering approach.\n\n        :param population_size: The total number of people in the simulation.\n        :return: An array of initial positions for the population.\n        \"\"\"\n        gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\n        gmm.fit(np.random.rand(100, 2))\n        positions = gmm.sample(population_size)[0]\n        return np.clip(positions * 100, 0, 100)  # Scale and clip to fit the environment grid\n\n    def run(self, days: int) -> None:\n        \"\"\"\n        Executes the simulation over a specified number of days.\n\n        :param days: The number of days to run the simulation.\n        \"\"\"\n        for _ in range(days):\n            self.time_step += 1\n\n            for person in self.people:\n                person.move()\n\n            positions = np.array([person.position for person in self.people])\n            self.environment.update_tree(positions)\n\n            for person in self.people:\n                if person.infected_status == 'infected':\n                    indices = self.environment.get_agents_within_radius(person.position, person.interaction_radius)\n                    for idx in indices:\n                        other = self.people[idx]\n                        if person != other:\n                            person.interact(other)\n                person.recover()\n\n            infected_count = sum(p.infected_status == 'infected' for p in self.people)\n            self.infection_counts.append(infected_count)\n\n    def evaluate(self) -> Dict[str, float]:\n        \"\"\"\n        Evaluates the simulation metrics.\n\n        :return: A dictionary containing infection_rate, recovery_rate, and peak_infection_day.\n        \"\"\"\n        peak_infection_day = self.infection_counts.index(max(self.infection_counts)) if self.infection_counts else -1\n        metrics = {\n            'infection_rate': sum(1 for p in self.people if p.infected_status == 'infected') / len(self.people),\n            'recovery_rate': sum(1 for p in self.people if p.infected_status == 'recovered') / len(self.people),\n            'peak_infection_day': peak_infection_day\n        }\n        return metrics\n\n    def visualize(self) -> None:\n        \"\"\"\n        Visualizes the results of the simulation.\n\n        Displays a bar chart of the health status distribution of the population at the end of the simulation\n        and a line graph showing the number of infections over time.\n        \"\"\"\n        # Visualize health status distribution\n        statuses = [p.infected_status for p in self.people]\n        labels, counts = np.unique(statuses, return_counts=True)\n        plt.figure(figsize=(10, 5))\n        plt.subplot(1, 2, 1)\n        plt.bar(labels, counts)\n        plt.title('Simulation Results')\n        plt.xlabel('Health Status')\n        plt.ylabel('Count')\n        \n        # Visualize infection curve over time\n        plt.subplot(1, 2, 2)\n        plt.plot(self.infection_counts, label='Infected')\n        plt.title('Infection Over Time')\n        plt.xlabel('Days')\n        plt.ylabel('Number of Infected People')\n        plt.tight_layout()\n        plt.show()\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"\n        Saves the simulation results to a file.\n\n        :param filename: The name of the file to save the results.\n        \"\"\"\n        if not filename:\n            logging.error('Invalid filename: Filename cannot be empty.')\n            return\n        try:\n            os.makedirs(os.path.dirname(filename), exist_ok=True)\n            with open(filename, 'w') as file:\n                file.write('infected_status,infection_chance,recovery_chance,interaction_rate\\n')\n                for person in self.people:\n                    file.write(f\"{person.infected_status},{person.infection_chance},{person.recovery_chance},{person.interaction_rate}\\n\")\n        except PermissionError as e:\n            logging.error(f'Permission error while writing the file: {e}')\n        except IOError as e:\n            logging.error(f'File I/O error: {e}')\n        except Exception as e:\n            logging.error(f'An unexpected error occurred while writing to the file: {e}')\n\n    def reset(self) -> None:\n        \"\"\"\n        Resets or reinitializes the simulation, allowing repeated runs without re-instantiating the class.\n        \"\"\"\n        self.__init__(len(self.people), sum(p.infected_status == 'infected' for p in self.people), self.transmission_probability, self.recovery_chance)\n\ndef main():\n    # Example simulation setup\n    population_size = 1000\n    initial_infected = int(population_size * 0.01)  # 1% initially infected\n    transmission_probability = 0.05\n    recovery_chance = 0.99\n    recovery_time = 14\n\n    sim = Simulation(population_size, initial_infected, transmission_probability, recovery_chance, recovery_time)\n    sim.run(30)\n    results = sim.evaluate()\n    logging.info(f\"Simulation results: {results}\")\n    sim.visualize()\n    sim.save_results('simulation_results.txt')\n\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 295 lines of code containing 3 classes and 16 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "infect"
    ]
  }
}