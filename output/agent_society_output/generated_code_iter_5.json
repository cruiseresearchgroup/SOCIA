{
  "code": "import os\nimport json\nimport random\nimport logging\nimport openai\nimport pandas as pd\nimport time\nfrom typing import List, Dict, Tuple, Any\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\n\n# Configure paths\nPROJECT_ROOT = os.environ.get(\"PROJECT_ROOT\", \".\")\nDATA_PATH = os.environ.get(\"DATA_PATH\", \"data_fitting/agent_society/\")\nDATA_DIR = os.path.join(PROJECT_ROOT, DATA_PATH)\n\n# Load OpenAI API key\nopenai.api_key = os.getenv('OPENAI_API_KEY')\nif openai.api_key is None:\n    try:\n        from keys import OPENAI_API_KEY\n        openai.api_key = OPENAI_API_KEY\n    except ImportError:\n        logging.error(\"OpenAI API key is missing. Please provide the API key through 'keys.py' or as an environment variable.\")\n        raise RuntimeError(\"OpenAI API key is required for running the simulation.\")\n\ndef load_json_file(filename: str) -> Dict[str, Any]:\n    \"\"\"Load data from a JSON file.\"\"\"\n    file_path = os.path.join(DATA_DIR, filename)\n    try:\n        with open(file_path, 'r') as file:\n            data = json.load(file)\n            if not data:\n                logging.warning(f\"The file {filename} is empty.\")\n            return data\n    except FileNotFoundError:\n        logging.error(f\"The file {filename} was not found in {DATA_DIR}.\")\n    except json.JSONDecodeError:\n        logging.error(f\"The file {filename} contains malformed JSON.\")\n    except PermissionError:\n        logging.error(f\"Permission denied when trying to open the file {filename}.\")\n    except IOError as e:\n        logging.error(f\"An unexpected IO error occurred while reading the file {filename}: {e}\")\n    return {}\n\n# Load data\nuser_data = load_json_file('user_sample.json')\nitem_data = load_json_file('item_sample.json')\nreview_data = load_json_file('review_sample.json')\namazon_data = load_json_file('amazon_train_sample.json')\ngoodreads_data = load_json_file('goodreads_train_sample.json')\nyelp_data = load_json_file('yelp_train_sample.json')\n\nclass User:\n    \"\"\"User entity in the simulation.\"\"\"\n    \n    def __init__(self, user_id: str, preferences: Dict[str, Any], review_history: List[Tuple[str, int, str]], rating_tendency: float):\n        self.id = user_id\n        self.preferences = preferences\n        self.review_history = review_history\n        self.rating_tendency = rating_tendency\n\n    def write_review(self, product: 'Product') -> Tuple[int, str]:\n        \"\"\"Simulates writing a review for a product.\"\"\"\n        review_text = self.generate_review_text(product)\n        rating = self.rate_product(product)\n        self.review_history.append((product.id, rating, review_text))\n        return rating, review_text\n\n    def generate_review_text(self, product: 'Product') -> str:\n        \"\"\"Generate review text using OpenAI's API.\"\"\"\n        historical_reviews_text = ' '.join(rev[2] for rev in self.review_history if rev[0] == product.id)\n        prompt = (f\"User {self.id} with preferences {self.preferences} is reviewing product {product.id} \"\n                  f\"in category {product.category}. Consider historical reviews: {historical_reviews_text}\")\n\n        response = None\n        for attempt in range(3):\n            try:\n                response = openai.Completion.create(\n                    model=\"text-davinci-003\",\n                    prompt=prompt,\n                    max_tokens=100\n                )\n                if 'choices' in response and response['choices']:\n                    break\n            except (openai.error.OpenAIError, openai.error.APIConnectionError, openai.error.Timeout, openai.error.RateLimitError) as e:\n                logging.error(f\"Error generating review text: {e}\")\n                if attempt < 2:\n                    logging.info(f\"Retrying OpenAI API call. Attempt {attempt + 2}.\")\n                    time.sleep(2 ** attempt)\n                    \n        review_text = response['choices'][0]['text'].strip() if response and 'choices' in response and response['choices'] else \"Error generating review text.\"\n        return review_text\n\n    def rate_product(self, product: 'Product') -> int:\n        \"\"\"Rate the product based on user preferences.\"\"\"\n        base_rating = random.uniform(1, 5)\n        preference_score = self.preferences.get(product.category, 0)\n        rating = base_rating + preference_score * self.rating_tendency\n        return max(1, min(5, round(rating)))\n\nclass Product:\n    \"\"\"Product entity in the simulation.\"\"\"\n    \n    def __init__(self, item_id: str, category: str, average_rating: float, review_count: int, attributes: Dict[str, Any]):\n        self.id = item_id\n        self.category = category\n        self.average_rating = average_rating\n        self.review_count = review_count\n        self.attributes = attributes\n\n    def receive_review(self, rating: int) -> None:\n        \"\"\"Process an incoming review by updating the review count and average rating.\"\"\"\n        self.review_count += 1\n        self.average_rating = ((self.average_rating * (self.review_count - 1)) + rating) / self.review_count\n\nclass PlanningAgent:\n    \"\"\"Agent responsible for creating plans for users to review items.\"\"\"\n    \n    def create_plan(self, user_id: str, item_id: str) -> Dict[str, str]:\n        \"\"\"Create a plan for a user to review an item.\"\"\"\n        return {\"user_id\": user_id, \"item_id\": item_id, \"action\": \"write_review\"}\n\nclass MemoryAgent:\n    \"\"\"Memory agent to store and retrieve user, item, and historical review information.\"\"\"\n    \n    def __init__(self, user_data: Dict[str, Any], item_data: Dict[str, Any], review_data: Dict[str, Any]):\n        self.user_data = user_data\n        self.item_data = item_data\n        self.review_data = review_data\n\n    def retrieve_user_info(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Retrieve user information.\"\"\"\n        user_info = self.user_data.get(user_id, {})\n        if not user_info:\n            logging.warning(f\"User {user_id} not found.\")\n        return user_info\n\n    def retrieve_item_info(self, item_id: str) -> Dict[str, Any]:\n        \"\"\"Retrieve item information.\"\"\"\n        item_info = self.item_data.get(item_id, {})\n        if not item_info:\n            logging.warning(f\"Item {item_id} not found.\")\n        return item_info\n\n    def retrieve_review_history(self, user_id: str, item_id: str) -> List[Tuple[str, int, str]]:\n        \"\"\"Retrieve historical review information.\"\"\"\n        return self.review_data.get(user_id, {}).get(item_id, [])\n\nclass ReasoningAgent:\n    \"\"\"Reasoning agent using LLM to simulate the review process.\"\"\"\n    \n    def simulate_review(self, user: User, product: Product, platform: str) -> Tuple[int, str]:\n        \"\"\"Simulate a review by a user for a product.\"\"\"\n        prompt = (f\"Simulate a review by user {user.id} for product {product.id} on {platform}. \"\n                  f\"User preferences: {user.preferences}. Product attributes: {product.attributes}.\")\n        \n        response = None\n        for attempt in range(3):\n            try:\n                response = openai.Completion.create(\n                    model=\"text-davinci-003\",\n                    prompt=prompt,\n                    max_tokens=150\n                )\n                if 'choices' in response and response['choices']:\n                    break\n            except (openai.error.OpenAIError, openai.error.APIConnectionError, openai.error.Timeout, openai.error.RateLimitError) as e:\n                logging.error(f\"Error during reasoning: {e}\")\n                if attempt < 2:\n                    logging.info(f\"Retrying OpenAI API call. Attempt {attempt + 2}.\")\n                    time.sleep(2 ** attempt)\n                    \n        review_text = response['choices'][0]['text'].strip() if response and 'choices' in response and response['choices'] else \"Error generating review text.\"\n        rating = user.rate_product(product)\n        return rating, review_text\n\nclass Simulation:\n    \"\"\"Main simulation class coordinating all agents and entities.\"\"\"\n    \n    def __init__(self, users: List[User], products: List[Product], user_data: Dict[str, Any], item_data: Dict[str, Any], review_data: Dict[str, Any]):\n        self.users = users\n        self.products = products\n        self.planning_agent = PlanningAgent()\n        self.memory_agent = MemoryAgent(user_data, item_data, review_data)\n        self.reasoning_agent = ReasoningAgent()\n\n    def run(self, days: int = 30) -> None:\n        \"\"\"Run the simulation for a given number of days.\"\"\"\n        for day in range(days):\n            for user in self.users:\n                try:\n                    if random.random() < 0.1:\n                        product = self.select_product_for_user(user)\n                        plan = self.planning_agent.create_plan(user.id, product.id)\n                        user_info = self.memory_agent.retrieve_user_info(plan['user_id'])\n                        item_info = self.memory_agent.retrieve_item_info(plan['item_id'])\n                        historical_reviews = self.memory_agent.retrieve_review_history(plan['user_id'], plan['item_id'])\n                        if user_info and item_info:\n                            user.review_history = historical_reviews\n                            platform = random.choice(['Amazon', 'Goodreads', 'Yelp'])\n                            rating, review = self.reasoning_agent.simulate_review(user, product, platform)\n                            product.receive_review(rating)\n                except Exception as e:\n                    logging.error(f\"An error occurred during the simulation run: {e}\")\n\n    def select_product_for_user(self, user: User) -> Product:\n        \"\"\"Select a product for the user to review based on their preferences and history.\"\"\"\n        try:\n            preferred_categories = [category for category, score in user.preferences.items() if score > 0]\n            preferred_products = [product for product in self.products if product.category in preferred_categories]\n            if preferred_products:\n                return random.choice(preferred_products)\n            return random.choice(self.products)\n        except Exception as e:\n            logging.error(f\"Error selecting product for user {user.id}: {e}\")\n            return random.choice(self.products)\n\n    def evaluate(self) -> None:\n        \"\"\"Evaluate the results of the simulation.\"\"\"\n        total_review_count = 0\n        total_rating_sum = 0\n        for product in self.products:\n            total_review_count += product.review_count\n            total_rating_sum += product.average_rating * product.review_count\n        if total_review_count > 0:\n            average_rating = total_rating_sum / total_review_count\n            logging.info(f\"Average rating across all products: {average_rating}\")\n        else:\n            logging.info(\"No reviews available for evaluation.\")\n\n    def save_results(self, filename: str) -> None:\n        \"\"\"Save the results of the simulation to a CSV file.\"\"\"\n        results = {\"users\": [user.id for user in self.users],\n                   \"products\": [product.id for product in self.products]}\n        df = pd.DataFrame(results)\n        df.to_csv(filename, index=False)\n\ndef main() -> None:\n    \"\"\"Main function to initialize entities and run the simulation.\"\"\"\n    if not user_data or not item_data:\n        logging.error(\"User data or item data not loaded. Exiting.\")\n        return\n\n    users = [User(user['user_id'], user.get('preferences', {}), [], user.get('rating_tendency', 0)) for user in user_data.values()]\n    products = [Product(item['item_id'], item.get('category', ''), item['average_rating'], item['review_count'], item.get('attributes', {})) for item in item_data.values()]\n\n    simulation = Simulation(users, products, user_data, item_data, review_data)\n    simulation.run()\n    simulation.evaluate()\n    simulation.save_results(\"results.csv\")\n\n# Execute main for both direct execution and sandbox wrapper invocation\nmain()",
  "code_summary": "Generated 255 lines of code containing 6 classes and 19 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "User",
      "Product"
    ],
    "behaviors": [
      "write_review",
      "rate_product",
      "receive_review"
    ]
  }
}