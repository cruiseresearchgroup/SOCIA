{
  "model_type": "agent_based",
  "description": "An agent-based simulation of a simple SIR-like epidemic spread in a non-spatial population. Individuals (agents) have health states (Susceptible, Infected, Recovered) and interact randomly, potentially transmitting the virus.",
  "entities": [
    {
      "name": "Person",
      "attributes": [
        "health_status",
        "time_in_infected_state"
      ],
      "behaviors": [
        "transition_to_infected",
        "transition_to_recovered"
      ],
      "initialization": {
        "method": "specified_and_random",
        "parameters": {
          "initial_infected_count": "Number of agents initially set to 'Infected'",
          "other_agents_status": "'Susceptible'"
        }
      }
    }
  ],
  "behaviors": [
    {
      "name": "transition_to_infected",
      "description": "An agent in the 'Susceptible' state may transition to the 'Infected' state upon contact with an 'Infected' agent, based on the transmission probability.",
      "applicable_to": [
        "Person"
      ],
      "parameters": {
        "transmission_probability": "Probability of transmission per contact"
      },
      "algorithm": "If agent is Susceptible and has contact with an Infected agent, generate a random number between 0 and 1. If the number is less than or equal to transmission_probability, change agent's status to Infected and reset time_in_infected_state to 0. This transition is typically handled during the interaction phase."
    },
    {
      "name": "transition_to_recovered",
      "description": "An agent in the 'Infected' state transitions to the 'Recovered' state after remaining infected for a specified duration.",
      "applicable_to": [
        "Person"
      ],
      "parameters": {
        "infection_duration_steps": "Number of simulation steps an agent remains Infected"
      },
      "algorithm": "If agent is Infected, increment time_in_infected_state. If time_in_infected_state reaches or exceeds infection_duration_steps, change agent's status to Recovered."
    }
  ],
  "interactions": [
    {
      "name": "Contact and Transmission",
      "description": "An 'Infected' agent comes into contact with another agent. If the contacted agent is 'Susceptible', there is a probability of transmission.",
      "entities_involved": [
        "Person",
        "Person"
      ],
      "trigger": "Random contact between agents during a simulation step.",
      "effect": "Potential state transition from Susceptible to Infected for the contacted agent."
    }
  ],
  "environment": {
    "type": "non-spatial",
    "dimensions": null,
    "time_step": 1,
    "time_unit": "step"
  },
  "parameters": {
    "population_size": 1000,
    "initial_infected_count": 10,
    "transmission_probability": 0.05,
    "infection_duration_steps": 14,
    "contacts_per_person_per_step": 5,
    "simulation_steps": 100
  },
  "initialization": {
    "population_size": "parameter: population_size",
    "random_seed": null,
    "agent_creation": "Create population_size Person agents.",
    "state_assignment": "Randomly select initial_infected_count agents and set their health_status to 'Infected' and time_in_infected_state to 0. Set all other agents' health_status to 'Susceptible' and time_in_infected_state to 0."
  },
  "algorithms": {
    "simulation_step_execution": "For each simulation step:\n1. Initialize a set, `newly_infected_ids`, to store IDs of agents who become infected in this step.\n2. **Interaction Phase:** Iterate through each agent in the population. If an agent is 'Infected', randomly select `contacts_per_person_per_step` other agents. For each selected agent, if they are 'Susceptible', apply the 'transition_to_infected' logic (check transmission probability) and add their ID to `newly_infected_ids` if transmission occurs.\n3. **State Update Phase (Infection):** Iterate through the `newly_infected_ids` set. For each ID, find the corresponding agent. If the agent's status is still 'Susceptible' (to avoid double-infection or infecting already recovered in the same step), change their health_status to 'Infected' and set time_in_infected_state to 0.\n4. **State Update Phase (Recovery):** Iterate through all agents. If an agent is 'Infected', increment their time_in_infected_state. If time_in_infected_state reaches `infection_duration_steps`, change their health_status to 'Recovered'.\n5. **Metric Collection:** Count the number of agents in each state (Susceptible, Infected, Recovered). Update cumulative total infections and peak infected count. Store counts for the current step.",
    "metric_collection": "At the end of each simulation step, iterate through the population to count agents by health_status. Maintain running counts for total infections (cumulative transitions to Infected) and track the maximum 'Infected' count observed across all steps."
  },
  "data_sources": [],
  "code_structure": {
    "files": [
      {
        "name": "agent.py",
        "description": "Defines the Person class with attributes (health_status, time_in_infected_state) and potentially methods for state transitions (though these might be handled by the simulation runner)."
      },
      {
        "name": "simulation.py",
        "description": "Contains the main Simulation class. Holds the population (list of agents), parameters, and the logic for running the simulation loop, handling interactions, updating states, and collecting metrics."
      },
      {
        "name": "main.py",
        "description": "Entry point of the script. Parses command-line arguments or loads parameters, initializes the Simulation object, runs the simulation, and outputs or visualizes the results (metrics)."
      },
      {
        "name": "utils.py",
        "description": "Optional: Helper functions, e.g., for random number generation or population initialization."
      }
    ],
    "dependencies": [
      "random",
      "collections"
    ]
  }
}