{
  "code": "import random\nimport enum\nimport collections\nimport matplotlib.pyplot as plt\nimport math\n\n# --- config.py ---\n\nclass SimulationConfig:\n    \"\"\"\n    Defines parameters for the Simple Epidemic Simulation.\n    \"\"\"\n    def __init__(self,\n                 population_size: int = 1000,\n                 initial_infected_count: int = 1,\n                 transmission_probability: float = 0.05,\n                 infection_duration_steps: int = 10,\n                 contact_rate_per_person_per_step: float = 5.0,\n                 simulation_steps: int = 100,\n                 random_seed: int = None):\n\n        if not isinstance(population_size, int) or population_size <= 0:\n            raise ValueError(\"population_size must be a positive integer.\")\n        if not isinstance(initial_infected_count, int) or initial_infected_count < 0:\n            raise ValueError(\"initial_infected_count must be a non-negative integer.\")\n        if initial_infected_count > population_size:\n             raise ValueError(\"initial_infected_count cannot exceed population_size.\")\n        if not isinstance(transmission_probability, (int, float)) or not (0.0 <= transmission_probability <= 1.0):\n            raise ValueError(\"transmission_probability must be a float between 0.0 and 1.0.\")\n        if not isinstance(infection_duration_steps, int) or infection_duration_steps <= 0:\n            raise ValueError(\"infection_duration_steps must be a positive integer.\")\n        if not isinstance(contact_rate_per_person_per_step, (int, float)) or contact_rate_per_person_per_step < 0:\n             raise ValueError(\"contact_rate_per_person_per_step must be a non-negative number.\")\n        if not isinstance(simulation_steps, int) or simulation_steps <= 0:\n            raise ValueError(\"simulation_steps must be a positive integer.\")\n        if random_seed is not None and not isinstance(random_seed, int):\n             raise ValueError(\"random_seed must be an integer or None.\")\n\n        self.population_size = population_size\n        self.initial_infected_count = initial_infected_count\n        self.transmission_probability = transmission_probability\n        self.infection_duration_steps = infection_duration_steps\n        self.contact_rate_per_person_per_step = contact_rate_per_person_per_step\n        self.simulation_steps = simulation_steps\n        self.random_seed = random_seed\n\n    def __str__(self):\n        return f\"SimulationConfig(\\n\" \\\n               f\"  population_size={self.population_size},\\n\" \\\n               f\"  initial_infected_count={self.initial_infected_count},\\n\" \\\n               f\"  transmission_probability={self.transmission_probability},\\n\" \\\n               f\"  infection_duration_steps={self.infection_duration_steps},\\n\" \\\n               f\"  contact_rate_per_person_per_step={self.contact_rate_per_person_per_step},\\n\" \\\n               f\"  simulation_steps={self.simulation_steps},\\n\" \\\n               f\"  random_seed={self.random_seed}\\n\" \\\n               f\")\"\n\n# --- agent.py ---\n\nclass HealthState(enum.Enum):\n    \"\"\"\n    Represents the possible health states of a Person agent.\n    \"\"\"\n    SUSCEPTIBLE = \"Susceptible\"\n    INFECTED = \"Infected\"\n    RECOVERED = \"Recovered\"\n\nclass Person:\n    \"\"\"\n    Represents an individual agent in the epidemic simulation.\n    \"\"\"\n    def __init__(self, agent_id: int, initial_state: HealthState, current_step: int):\n        \"\"\"\n        Initializes a Person agent.\n\n        Args:\n            agent_id: A unique identifier for the agent.\n            initial_state: The starting HealthState of the agent.\n            current_step: The current simulation step (used to record infection time).\n        \"\"\"\n        self.id = agent_id\n        self.health_state = initial_state\n        self.infection_start_step = current_step if initial_state == HealthState.INFECTED else None\n        self._marked_for_infection = False # Temporary flag set during interactions\n\n    def __repr__(self):\n        return f\"Person(id={self.id}, state={self.health_state.value}, infected_at={self.infection_start_step})\"\n\n    def step(self, current_step: int, environment):\n        \"\"\"\n        Executes the agent's behaviors for a single simulation step.\n\n        Args:\n            current_step: The current simulation step number.\n            environment: The simulation environment containing other agents and parameters.\n        \"\"\"\n        # Reset temporary flags at the start of the step processing\n        self._marked_for_infection = False\n\n        # Behavior: interact_with_others\n        self._interact_with_others(environment)\n\n        # Behavior: transition_state_based_on_rules\n        # This needs to happen AFTER all potential interactions have marked agents\n        # within this step. The actual state transition logic is separate to ensure\n        # all interactions for the step are considered before anyone changes state.\n        # The transition logic is called by the environment/simulation runner\n        # after all agents have performed their interactions.\n\n    def _interact_with_others(self, environment):\n        \"\"\"\n        Attempts to make contacts with other agents in the environment.\n\n        Args:\n            environment: The simulation environment.\n        \"\"\"\n        if self.health_state == HealthState.RECOVERED:\n            # Recovered individuals do not interact in terms of spreading/getting infected\n            # (though they might still have contacts, those contacts have no effect)\n            return\n\n        # Determine number of contacts to attempt\n        num_contacts = round(environment.params.contact_rate_per_person_per_step)\n\n        if environment.params.population_size <= 1:\n             # Cannot interact with others if population is 1 or less\n             return\n\n        # List of other agents\n        other_agents = [agent for agent in environment.agents if agent.id != self.id]\n\n        for _ in range(num_contacts):\n            # Select a random agent to interact with (excluding self)\n            if not other_agents: # Should not happen if population_size > 1, but good check\n                break\n            other_agent = environment.rng.choice(other_agents)\n\n            # Interaction: potential_infection_contact\n            Person.potential_infection_contact(self, other_agent, environment.params.transmission_probability, environment.rng)\n\n    @staticmethod\n    def potential_infection_contact(agent1, agent2, transmission_probability: float, rng):\n        \"\"\"\n        Handles a potential infection contact between two agents.\n        Marks a susceptible agent for infection if contact conditions are met.\n\n        Args:\n            agent1: The first agent involved in the contact.\n            agent2: The second agent involved in the contact.\n            transmission_probability: The probability of transmission.\n            rng: The random number generator instance.\n        \"\"\"\n        susceptible_agent = None\n        infected_agent = None\n\n        if agent1.health_state == HealthState.SUSCEPTIBLE and agent2.health_state == HealthState.INFECTED:\n            susceptible_agent = agent1\n            infected_agent = agent2\n        elif agent1.health_state == HealthState.INFECTED and agent2.health_state == HealthState.SUSCEPTIBLE:\n            susceptible_agent = agent2\n            infected_agent = agent1\n\n        # If a susceptible agent and an infected agent are involved\n        if susceptible_agent and infected_agent:\n            # Check for transmission\n            if rng.random() < transmission_probability:\n                # Mark the susceptible agent for infection. The state change\n                # happens later in the transition_state method.\n                susceptible_agent._marked_for_infection = True\n\n    def transition_state(self, current_step: int, infection_duration_steps: int) -> bool:\n        \"\"\"\n        Updates the agent's health state based on rules and current conditions.\n\n        Args:\n            current_step: The current simulation step number.\n            infection_duration_steps: The number of steps an agent stays infected.\n\n        Returns:\n            True if the agent transitioned from Susceptible to Infected in this step,\n            False otherwise. (Used for counting new cases).\n        \"\"\"\n        transitioned_to_infected = False\n\n        if self.health_state == HealthState.SUSCEPTIBLE:\n            # If marked for infection during interactions in this step\n            if self._marked_for_infection:\n                self.health_state = HealthState.INFECTED\n                self.infection_start_step = current_step\n                transitioned_to_infected = True\n        elif self.health_state == HealthState.INFECTED:\n            # Check if it's time to recover\n            if current_step - self.infection_start_step >= infection_duration_steps:\n                self.health_state = HealthState.RECOVERED\n                self.infection_start_step = None # Recovered agents don't have a start step\n        # Recovered agents remain Recovered\n\n        # Reset the flag after processing transitions\n        self._marked_for_infection = False # Ensure it's reset whether transition happened or not\n\n        return transitioned_to_infected\n\n\n# --- metrics.py ---\n\nclass SimulationMetrics:\n    \"\"\"\n    Collects and stores simulation metrics over time.\n    \"\"\"\n    def __init__(self, initial_infected_count: int):\n        \"\"\"\n        Initializes the metrics storage.\n\n        Args:\n            initial_infected_count: The number of agents initially infected.\n        \"\"\"\n        self.steps = []\n        self.susceptible_counts = []\n        self.infected_counts = []\n        self.recovered_counts = []\n        self.total_cases = [initial_infected_count] # Cumulative count\n\n    def collect(self, current_step: int, agents: list, new_infections_in_step: int):\n        \"\"\"\n        Collects the current state counts and updates metrics.\n\n        Args:\n            current_step: The current simulation step.\n            agents: The list of all agents in the simulation.\n            new_infections_in_step: The number of agents who transitioned from S to I\n                                    in the current step.\n        \"\"\"\n        self.steps.append(current_step)\n\n        susceptible_count = sum(1 for agent in agents if agent.health_state == HealthState.SUSCEPTIBLE)\n        infected_count = sum(1 for agent in agents if agent.health_state == HealthState.INFECTED)\n        recovered_count = sum(1 for agent in agents if agent.health_state == HealthState.RECOVERED)\n\n        self.susceptible_counts.append(susceptible_count)\n        self.infected_counts.append(infected_count)\n        self.recovered_counts.append(recovered_count)\n\n        # Update total cases (cumulative S->I transitions)\n        # The initial total cases is the initial infected count (step 0).\n        # For steps > 0, add the new infections from the *previous* step's transitions\n        # (since transitions happen *after* interactions). Or, more simply,\n        # the total cases at step T is the sum of initial infected + all S->I transitions up to step T.\n        # The `new_infections_in_step` correctly represents S->I transitions that *just* happened.\n        current_total_cases = self.total_cases[-1] + new_infections_in_step\n        self.total_cases.append(current_total_cases)\n\n        # Optional: Add validation checks here during collection\n        total_population = susceptible_count + infected_count + recovered_count\n        if total_population != len(agents):\n             print(f\"Warning: Population conservation violated at step {current_step}! \"\n                   f\"Current sum: {total_population}, Expected: {len(agents)}\")\n\n\n# --- environment.py ---\n\nclass Environment:\n    \"\"\"\n    Manages the simulation environment and the collection of agents.\n    Orchestrates the simulation steps.\n    \"\"\"\n    def __init__(self, params: SimulationConfig):\n        \"\"\"\n        Initializes the environment.\n\n        Args:\n            params: The simulation configuration parameters.\n        \"\"\"\n        self.params = params\n        self.agents = []\n        self.current_step = 0\n        self.rng = random.Random(params.random_seed) # Use a dedicated RNG for reproducibility\n\n    def setup(self):\n        \"\"\"\n        Initializes the agents based on the configuration parameters.\n        \"\"\"\n        self.agents = []\n        initial_infected_count = self.params.initial_infected_count\n        population_size = self.params.population_size\n\n        if initial_infected_count > population_size:\n             raise ValueError(\"Initial infected count cannot be greater than population size.\")\n\n        # Create agents and assign initial states\n        # Ensure unique IDs\n        agent_ids = list(range(population_size))\n        self.rng.shuffle(agent_ids) # Shuffle IDs just in case order matters later\n\n        for i in range(population_size):\n            agent_id = i # Use simple sequential ID for now\n            if i < initial_infected_count:\n                # Initially infected agents start at step 0\n                agent = Person(agent_id, HealthState.INFECTED, self.current_step)\n            else:\n                agent = Person(agent_id, HealthState.SUSCEPTIBLE, self.current_step)\n            self.agents.append(agent)\n\n        # Optional: Shuffle agents list to remove any initial state ordering bias\n        self.rng.shuffle(self.agents)\n\n\n    def step(self) -> int:\n        \"\"\"\n        Executes a single simulation step.\n\n        Returns:\n            The number of new infections (S->I transitions) that occurred in this step.\n        \"\"\"\n        self.current_step += 1\n        new_infections_this_step = 0\n\n        # Phase 1: Agents perform interactions (which *mark* susceptible agents)\n        # Shuffle agents each step to randomize interaction order\n        self.rng.shuffle(self.agents)\n        for agent in self.agents:\n            agent.step(self.current_step, self) # agent._interact_with_others is called here\n\n        # Phase 2: Agents transition states based on their state and marks from interactions\n        # We need to iterate through agents again to process transitions after all\n        # interactions for the step are complete.\n        for agent in self.agents:\n            # agent.transition_state is called here\n            if agent.transition_state(self.current_step, self.params.infection_duration_steps):\n                 new_infections_this_step += 1\n\n        return new_infections_this_step\n\n# --- visualization.py ---\n\ndef plot_sir_curves(metrics: SimulationMetrics, population_size: int):\n    \"\"\"\n    Plots the Susceptible, Infected, and Recovered counts over time.\n\n    Args:\n        metrics: The SimulationMetrics object containing the collected data.\n        population_size: The total population size for normalization.\n    \"\"\"\n    if not metrics.steps:\n        print(\"No metrics collected to plot.\")\n        return\n\n    plt.figure(figsize=(10, 6))\n\n    # Plot counts\n    plt.plot(metrics.steps, metrics.susceptible_counts, label=HealthState.SUSCEPTIBLE.value, color='blue')\n    plt.plot(metrics.steps, metrics.infected_counts, label=HealthState.INFECTED.value, color='red')\n    plt.plot(metrics.steps, metrics.recovered_counts, label=HealthState.RECOVERED.value, color='green')\n\n    # Plot total cases (optional, can be on a secondary axis or separate plot)\n    # plt.plot(metrics.steps, metrics.total_cases, label='Total Cases (Cumulative)', color='purple', linestyle='--')\n\n\n    plt.xlabel(\"Simulation Step\")\n    plt.ylabel(\"Number of Individuals\")\n    plt.title(\"Simple SIR Epidemic Simulation\")\n    plt.legend()\n    plt.grid(True)\n    plt.ylim(0, population_size + 10) # Ensure y-axis starts at 0 and goes slightly above pop size\n    plt.xlim(0, metrics.steps[-1]) # Ensure x-axis starts at 0\n\n    plt.show()\n\ndef plot_total_cases(metrics: SimulationMetrics):\n    \"\"\"\n    Plots the cumulative total cases over time.\n\n    Args:\n        metrics: The SimulationMetrics object containing the collected data.\n    \"\"\"\n    if not metrics.steps:\n        print(\"No metrics collected to plot.\")\n        return\n\n    plt.figure(figsize=(10, 6))\n\n    plt.plot(metrics.steps, metrics.total_cases, label='Total Cases (Cumulative)', color='purple')\n\n    plt.xlabel(\"Simulation Step\")\n    plt.ylabel(\"Number of Individuals\")\n    plt.title(\"Simple SIR Epidemic Simulation: Total Cases\")\n    plt.legend()\n    plt.grid(True)\n    plt.ylim(0, max(metrics.total_cases) * 1.1 if metrics.total_cases else 10)\n    plt.xlim(0, metrics.steps[-1])\n\n    plt.show()\n\n\n# --- simulation.py ---\n\ndef run_simulation(params: SimulationConfig) -> SimulationMetrics:\n    \"\"\"\n    Sets up and runs the epidemic simulation.\n\n    Args:\n        params: The simulation configuration parameters.\n\n    Returns:\n        A SimulationMetrics object containing the results.\n    \"\"\"\n    print(\"Setting up simulation with parameters:\")\n    print(params)\n\n    environment = Environment(params)\n    environment.setup()\n\n    # Initial metric collection\n    initial_infected_count = sum(1 for agent in environment.agents if agent.health_state == HealthState.INFECTED)\n    metrics = SimulationMetrics(initial_infected_count=initial_infected_count)\n    metrics.collect(environment.current_step, environment.agents, new_infections_in_step=0) # Collect initial state at step 0\n\n    print(f\"Running simulation for {params.simulation_steps} steps...\")\n    for step in range(1, params.simulation_steps + 1):\n        if step % 10 == 0 or step == 1 or step == params.simulation_steps:\n            print(f\"  Step {step}/{params.simulation_steps}\")\n\n        new_infections = environment.step()\n        metrics.collect(environment.current_step, environment.agents, new_infections)\n\n    print(\"Simulation finished.\")\n    return metrics\n\ndef main():\n    \"\"\"\n    Main function to run the simulation and display results.\n    \"\"\"\n    # Define simulation parameters\n    # You can change these values to explore different scenarios\n    config = SimulationConfig(\n        population_size=1000,\n        initial_infected_count=5,\n        transmission_probability=0.08,\n        infection_duration_steps=14,\n        contact_rate_per_person_per_step=10.0,\n        simulation_steps=200,\n        random_seed=42 # Set to None for a different run each time\n    )\n\n    # Run the simulation\n    simulation_results = run_simulation(config)\n\n    # Display results\n    plot_sir_curves(simulation_results, config.population_size)\n    plot_total_cases(simulation_results)\n\n    # Optional: Print final state counts\n    print(\"\\nFinal State Counts:\")\n    final_s = simulation_results.susceptible_counts[-1]\n    final_i = simulation_results.infected_counts[-1]\n    final_r = simulation_results.recovered_counts[-1]\n    final_total = final_s + final_i + final_r\n    print(f\"  Susceptible: {final_s}\")\n    print(f\"  Infected: {final_i}\")\n    print(f\"  Recovered: {final_r}\")\n    print(f\"  Total Population: {final_total} (Expected: {config.population_size})\")\n    print(f\"  Total Cases (Cumulative): {simulation_results.total_cases[-1]}\")\n\n    # Basic Validation Check: Population Conservation\n    if final_total == config.population_size:\n        print(\"Validation Check: Population Conservation - PASSED\")\n    else:\n        print(\"Validation Check: Population Conservation - FAILED\")\n\nif __name__ == \"__main__\":\n    main()",
  "code_summary": "Generated 470 lines of code containing 5 classes and 17 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "interact_with_others",
      "transition_state_based_on_rules"
    ]
  }
}