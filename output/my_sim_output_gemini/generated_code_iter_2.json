{
  "code": "import random\nimport matplotlib.pyplot as plt\nimport enum\n\n# Define Health Status states using an Enum for clarity\nclass HealthStatus(enum.Enum):\n    SUSCEPTIBLE = \"Susceptible\"\n    INFECTED = \"Infected\"\n    RECOVERED = \"Recovered\"\n\nclass Person:\n    \"\"\"\n    Represents an individual agent in the simulation.\n    \"\"\"\n    def __init__(self, id, initial_status):\n        \"\"\"\n        Initializes a Person agent.\n\n        Args:\n            id (int): Unique identifier for the agent.\n            initial_status (HealthStatus): The initial health status of the agent.\n        \"\"\"\n        if initial_status not in HealthStatus:\n             raise ValueError(f\"Invalid initial_status: {initial_status}\")\n\n        self.id = id\n        self.health_status = initial_status\n        self._ever_infected = (initial_status == HealthStatus.INFECTED) # Track for total_infections metric\n\n    def potentially_recover(self, recovery_probability):\n        \"\"\"\n        Behavior: An infected individual has a chance to recover.\n\n        Args:\n            recovery_probability (float): The probability of recovering in this step.\n\n        Returns:\n            bool: True if the agent recovered, False otherwise.\n        \"\"\"\n        if self.health_status == HealthStatus.INFECTED:\n            if random.random() < recovery_probability:\n                self.health_status = HealthStatus.RECOVERED\n                return True\n        return False\n\n    def attempt_infection_from(self, infected_person, transmission_probability):\n        \"\"\"\n        Interaction: A susceptible individual attempts to get infected by an infected person.\n        This method is called *on* the susceptible person.\n\n        Args:\n            infected_person (Person): The infected person attempting transmission.\n            transmission_probability (float): The probability of transmission during this interaction.\n\n        Returns:\n            bool: True if the agent became infected, False otherwise.\n        \"\"\"\n        if self.health_status == HealthStatus.SUSCEPTIBLE and \\\n           infected_person.health_status == HealthStatus.INFECTED:\n            if random.random() < transmission_probability:\n                # Note: State change is typically applied *after* all interactions\n                # are evaluated in a step. This method just indicates if infection *would* occur.\n                # The actual state change is handled in the simulation loop.\n                return True\n        return False\n\n    def __repr__(self):\n        return f\"Person(id={self.id}, status={self.health_status.value})\"\n\nclass Simulation:\n    \"\"\"\n    Manages the simulation environment, agents, parameters, and simulation loop.\n    \"\"\"\n    def __init__(self, parameters):\n        \"\"\"\n        Initializes the simulation.\n\n        Args:\n            parameters (dict): A dictionary containing simulation parameters.\n        \"\"\"\n        self.parameters = parameters\n        self.population_size = parameters.get(\"population_size\", 1000)\n        self.initial_infected_count = parameters.get(\"initial_infected_count\", 1)\n        self.transmission_probability = parameters.get(\"transmission_probability\", 0.1)\n        self.recovery_probability_per_step = parameters.get(\"recovery_probability_per_step\", 0.05)\n        self.simulation_steps = parameters.get(\"simulation_steps\", 100)\n        self.random_seed = parameters.get(\"random_seed\", None)\n\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n\n        self.agents = []\n        self._initialize_population()\n\n        # Metrics history\n        self._metrics_history = {\n            \"step\": [],\n            HealthStatus.SUSCEPTIBLE.value: [],\n            HealthStatus.INFECTED.value: [],\n            HealthStatus.RECOVERED.value: [],\n            \"Total Infections\": []\n        }\n\n        # Calculate initial metrics\n        self._current_metrics = self._calculate_metrics()\n        self._total_infections = self.initial_infected_count # Cumulative count\n\n        self._record_metrics(0) # Record initial state\n\n    def _initialize_population(self):\n        \"\"\"\n        Creates the agents and sets their initial health statuses.\n        \"\"\"\n        if self.initial_infected_count > self.population_size:\n            raise ValueError(\"Initial infected count cannot exceed population size.\")\n\n        # Create all agents as Susceptible initially\n        self.agents = [Person(id=i, initial_status=HealthStatus.SUSCEPTIBLE)\n                       for i in range(self.population_size)]\n\n        # Randomly select initial infected agents\n        infected_indices = random.sample(range(self.population_size), self.initial_infected_count)\n        for i in infected_indices:\n            self.agents[i].health_status = HealthStatus.INFECTED\n            self.agents[i]._ever_infected = True # Mark as ever infected\n\n        print(f\"Initialized population: {self.population_size} agents, \"\n              f\"{self.initial_infected_count} initially infected.\")\n\n    def _calculate_metrics(self):\n        \"\"\"\n        Calculates the current counts of agents in each health status.\n\n        Returns:\n            dict: A dictionary with current counts.\n        \"\"\"\n        counts = {status: 0 for status in HealthStatus}\n        for agent in self.agents:\n            counts[agent.health_status] += 1\n        return counts\n\n    def _record_metrics(self, step):\n        \"\"\"\n        Records the current metrics to the history.\n\n        Args:\n            step (int): The current simulation step number.\n        \"\"\"\n        current_counts = self._calculate_metrics()\n        self._metrics_history[\"step\"].append(step)\n        self._metrics_history[HealthStatus.SUSCEPTIBLE.value].append(current_counts[HealthStatus.SUSCEPTIBLE])\n        self._metrics_history[HealthStatus.INFECTED.value].append(current_counts[HealthStatus.INFECTED])\n        self._metrics_history[HealthStatus.RECOVERED.value].append(current_counts[HealthStatus.RECOVERED])\n        self._metrics_history[\"Total Infections\"].append(self._total_infections) # Record cumulative total\n\n        # Basic validation check: Population conservation\n        total_agents = sum(current_counts.values())\n        if total_agents != self.population_size:\n            print(f\"WARNING: Population size mismatch at step {step}! Expected {self.population_size}, got {total_agents}\")\n\n    def run(self):\n        \"\"\"\n        Runs the main simulation loop for the specified number of steps.\n        \"\"\"\n        print(\"Starting simulation...\")\n        for step in range(1, self.simulation_steps + 1):\n            # print(f\"Step {step}/{self.simulation_steps}\")\n\n            # Lists to track state changes for this step\n            agents_to_infect_ids = set()\n            agents_to_recover_ids = set()\n\n            # --- Step 2: Interactions (Virus Transmission) ---\n            # Perform 'population_size' random pairings\n            for _ in range(self.population_size):\n                # Select two distinct agents randomly\n                if self.population_size < 2:\n                    break # Cannot pair if less than 2 agents\n                agent1, agent2 = random.sample(self.agents, 2)\n\n                # Check for potential transmission\n                if agent1.health_status == HealthStatus.INFECTED and agent2.health_status == HealthStatus.SUSCEPTIBLE:\n                    if agent2.attempt_infection_from(agent1, self.transmission_probability):\n                        agents_to_infect_ids.add(agent2.id)\n                elif agent2.health_status == HealthStatus.INFECTED and agent1.health_status == HealthStatus.SUSCEPTIBLE:\n                     if agent1.attempt_infection_from(agent2, self.transmission_probability):\n                        agents_to_infect_ids.add(agent1.id)\n\n            # --- Step 3: Behaviors (Potentially Recover) ---\n            for agent in self.agents:\n                if agent.health_status == HealthStatus.INFECTED:\n                    if agent.potentially_recover(self.recovery_probability_per_step):\n                        agents_to_recover_ids.add(agent.id)\n\n            # --- Step 4: Apply State Changes ---\n            # It's important to iterate through the original agent list\n            # and apply changes based on the collected IDs/flags.\n            for agent in self.agents:\n                # Apply infection first (Susceptible -> Infected)\n                if agent.id in agents_to_infect_ids:\n                    # Ensure the agent is still Susceptible before infecting\n                    if agent.health_status == HealthStatus.SUSCEPTIBLE:\n                        agent.health_status = HealthStatus.INFECTED\n                        # Increment total infections only when a SUSCEPTIBLE person becomes INFECTED\n                        if not agent._ever_infected:\n                            self._total_infections += 1\n                            agent._ever_infected = True # Mark as ever infected\n\n                # Apply recovery (Infected -> Recovered)\n                # Only apply recovery if the agent is currently Infected\n                # (Could have just been infected in this step, or was already infected)\n                if agent.id in agents_to_recover_ids:\n                    if agent.health_status == HealthStatus.INFECTED:\n                         agent.health_status = HealthStatus.RECOVERED\n\n                # Validation check: Ensure state transitions are valid\n                if agent.health_status == HealthStatus.RECOVERED and agent.id in agents_to_infect_ids:\n                     print(f\"WARNING: Invalid state transition attempt for agent {agent.id} at step {step}: Recovered -> Infected\")\n                if agent.health_status == HealthStatus.SUSCEPTIBLE and agent.id in agents_to_recover_ids:\n                     print(f\"WARNING: Invalid state transition attempt for agent {agent.id} at step {step}: Susceptible -> Recovered\")\n\n\n            # --- Step 5: Update Metrics ---\n            self._current_metrics = self._calculate_metrics()\n            self._record_metrics(step)\n\n            # Validation check: Infected count limit\n            if self._current_metrics[HealthStatus.INFECTED] > self.population_size:\n                 print(f\"WARNING: Infected count ({self._current_metrics[HealthStatus.INFECTED]}) exceeds population size ({self.population_size}) at step {step}!\")\n\n\n        print(\"Simulation finished.\")\n        print(\"\\nFinal Metrics:\")\n        print(f\"Susceptible: {self._current_metrics[HealthStatus.SUSCEPTIBLE]}\")\n        print(f\"Infected: {self._current_metrics[HealthStatus.INFECTED]}\")\n        print(f\"Recovered: {self._current_metrics[HealthStatus.RECOVERED]}\")\n        print(f\"Total Individuals Ever Infected: {self._total_infections}\")\n\n\n    def get_metrics_history(self):\n        \"\"\"\n        Returns the collected metrics history.\n\n        Returns:\n            dict: A dictionary where keys are metric names and values are lists of values over time.\n        \"\"\"\n        return self._metrics_history\n\ndef visualize_results(metrics_history):\n    \"\"\"\n    Plots the simulation results over time.\n\n    Args:\n        metrics_history (dict): The metrics history from the simulation.\n    \"\"\"\n    steps = metrics_history[\"step\"]\n    susceptible = metrics_history[HealthStatus.SUSCEPTIBLE.value]\n    infected = metrics_history[HealthStatus.INFECTED.value]\n    recovered = metrics_history[HealthStatus.RECOVERED.value]\n    total_infected = metrics_history[\"Total Infections\"]\n\n    plt.figure(figsize=(12, 6))\n    plt.plot(steps, susceptible, label=HealthStatus.SUSCEPTIBLE.value, color='blue')\n    plt.plot(steps, infected, label=HealthStatus.INFECTED.value, color='red')\n    plt.plot(steps, recovered, label=HealthStatus.RECOVERED.value, color='green')\n    # plt.plot(steps, total_infected, label=\"Total Ever Infected\", color='purple', linestyle='--') # Optional: plot cumulative\n\n    plt.xlabel(\"Simulation Step\")\n    plt.ylabel(\"Number of Individuals\")\n    plt.title(\"Simple Epidemic Spread Over Time (SIR Model)\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\ndef main():\n    \"\"\"\n    Sets up parameters, runs the simulation, and visualizes results.\n    \"\"\"\n    simulation_parameters = {\n        \"population_size\": 1000,\n        \"initial_infected_count\": 1,\n        \"transmission_probability\": 0.1,\n        \"recovery_probability_per_step\": 0.05,\n        \"simulation_steps\": 200, # Increased steps to see more dynamics\n        \"random_seed\": 42 # Use a seed for reproducibility\n    }\n\n    # Basic parameter validation\n    if simulation_parameters[\"initial_infected_count\"] > simulation_parameters[\"population_size\"]:\n        print(\"Error: initial_infected_count cannot be greater than population_size.\")\n        return\n    if not (0 <= simulation_parameters[\"transmission_probability\"] <= 1):\n         print(\"Error: transmission_probability must be between 0 and 1.\")\n         return\n    if not (0 <= simulation_parameters[\"recovery_probability_per_step\"] <= 1):\n         print(\"Error: recovery_probability_per_step must be between 0 and 1.\")\n         return\n    if simulation_parameters[\"simulation_steps\"] < 0:\n         print(\"Error: simulation_steps cannot be negative.\")\n         return\n\n\n    sim = Simulation(simulation_parameters)\n    sim.run()\n    metrics = sim.get_metrics_history()\n    visualize_results(metrics)\n\nif __name__ == \"__main__\":\n    main()",
  "code_summary": "Generated 309 lines of code containing 3 classes and 12 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "potentially_recover"
    ]
  }
}