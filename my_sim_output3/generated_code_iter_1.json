{
  "code": "# Import necessary libraries\nimport numpy as np\nimport random\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nimport logging\n\n# Set up logging for error handling and tracing\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# Define the Person class and its behaviors\n@dataclass\nclass Person:\n    health_status: str\n    infection_time: Optional[int] = None\n    recovery_time: Optional[int] = None\n    immune_status: bool = False\n    x: int = field(default_factory=lambda: random.randint(0, 49))\n    y: int = field(default_factory=lambda: random.randint(0, 49))\n\n    def move(self, grid_size: int):\n        \"\"\"Simulates the movement of the person within the environment.\"\"\"\n        self.x = (self.x + random.choice([-1, 0, 1])) % grid_size\n        self.y = (self.y + random.choice([-1, 0, 1])) % grid_size\n\n    def interact(self, other, infection_probability: float, current_time: int):\n        \"\"\"Enables interaction between agents when they are in proximity.\"\"\"\n        if self.health_status == 'susceptible' and other.health_status == 'infected':\n            if not self.immune_status and random.random() < infection_probability:\n                self.become_infected(current_time)\n                \n    def become_infected(self, current_time: int):\n        \"\"\"Changes the health status of a susceptible person to infected.\"\"\"\n        self.health_status = 'infected'\n        self.infection_time = current_time\n        self.recovery_time = current_time + random.randint(10, 18)  # Average recovery time \u00b1 some variation\n\n    def recover(self, current_time: int):\n        \"\"\"Transitions an infected person to a recovered state after a certain period.\"\"\"\n        if self.health_status == 'infected' and current_time >= self.recovery_time:\n            self.health_status = 'recovered'\n            self.immune_status = True\n\n# Define the Environment class\nclass Environment:\n    def __init__(self, population_size: int, initial_infected: int, infection_probability: float, grid_size: int):\n        self.grid_size = grid_size\n        self.infection_probability = infection_probability\n        self.population = self.initialize_population(population_size, initial_infected)\n        self.time_step = 0\n\n    def initialize_population(self, population_size: int, initial_infected: int) -> List[Person]:\n        \"\"\"Initialize the population with a given number of initially infected individuals.\"\"\"\n        population = [Person(health_status='susceptible') for _ in range(population_size)]\n        for person in random.sample(population, initial_infected):\n            person.become_infected(self.time_step)\n        return population\n\n    def step(self):\n        \"\"\"Simulate one time step in the environment.\"\"\"\n        try:\n            for person in self.population:\n                person.move(self.grid_size)\n                \n            for i, person in enumerate(self.population):\n                for other in self.population[i + 1:]:\n                    if abs(person.x - other.x) <= 1 and abs(person.y - other.y) <= 1:\n                        person.interact(other, self.infection_probability, self.time_step)\n                        other.interact(person, self.infection_probability, self.time_step)\n            \n            for person in self.population:\n                person.recover(self.time_step)\n            \n            self.time_step += 1\n        except Exception as e:\n            logging.error(f\"Error during simulation step: {e}\")\n\n    def run_simulation(self, duration: int):\n        \"\"\"Run the simulation for a specified duration.\"\"\"\n        for _ in range(duration):\n            self.step()\n\n    def get_metrics(self):\n        \"\"\"Calculate and return the metrics of the simulation.\"\"\"\n        total_infected = sum(1 for person in self.population if person.immune_status)\n        peak_infection = max(self.time_step)\n        recovery_rate = sum(1 for person in self.population if person.health_status == 'recovered') / total_infected\n        return total_infected, peak_infection, recovery_rate\n\n# Visualization functions for displaying results\ndef visualize_simulation(environment: Environment):\n    susceptible = [person for person in environment.population if person.health_status == 'susceptible']\n    infected = [person for person in environment.population if person.health_status == 'infected']\n    recovered = [person for person in environment.population if person.health_status == 'recovered']\n\n    plt.figure(figsize=(10, 6))\n    plt.scatter([p.x for p in susceptible], [p.y for p in susceptible], color='blue', label='Susceptible', alpha=0.6)\n    plt.scatter([p.x for p in infected], [p.y for p in infected], color='red', label='Infected', alpha=0.6)\n    plt.scatter([p.x for p in recovered], [p.y for p in recovered], color='green', label='Recovered', alpha=0.6)\n    plt.title('Simulation State')\n    plt.xlabel('X Position')\n    plt.ylabel('Y Position')\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n# Main function to run the simulation\ndef main():\n    try:\n        # Parameters from the model plan\n        population_size = 1000\n        initial_infected = 10\n        infection_probability = 0.05\n        average_recovery_time = 14\n        simulation_duration = 100\n        grid_size = 50\n\n        # Initialize and run the simulation\n        environment = Environment(population_size, initial_infected, infection_probability, grid_size)\n        environment.run_simulation(simulation_duration)\n\n        # Visualize the final state of the simulation\n        visualize_simulation(environment)\n\n        # Print metrics\n        total_infected, peak_infection, recovery_rate = environment.get_metrics()\n        logging.info(f'Total Infected: {total_infected}')\n        logging.info(f'Peak Infection: {peak_infection}')\n        logging.info(f'Recovery Rate: {recovery_rate}')\n\n    except Exception as e:\n        logging.error(f\"Error in main simulation: {e}\")\n\n# Execute the simulation\nif __name__ == '__main__':\n    main()",
  "code_summary": "Generated 137 lines of code containing 2 classes and 11 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "become_infected",
      "recover"
    ]
  }
}