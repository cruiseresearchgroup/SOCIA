{
  "code": "import numpy as np\nimport random\nimport matplotlib.pyplot as plt\nfrom typing import List, Tuple\n\n# Constants for health statuses\nSUSCEPTIBLE = \"susceptible\"\nINFECTED = \"infected\"\nRECOVERED = \"recovered\"\n\nclass Person:\n    \"\"\"\n    Class representing an individual in the simulation.\n    \"\"\"\n\n    def __init__(self, health_status: str, infection_probability: float, recovery_time: int, location: Tuple[int, int]):\n        self.health_status = health_status\n        self.infection_probability = infection_probability\n        self.recovery_time = recovery_time\n        self.location = location\n\n    def move(self, grid_size: Tuple[int, int]):\n        \"\"\"\n        Move the person to a new location within the grid bounds, restricted to orthogonal directions.\n        \"\"\"\n        x, y = self.location\n        movement_choice = random.choice([(0, 1), (0, -1), (1, 0), (-1, 0)])\n        new_x = min(max(x + movement_choice[0], 0), grid_size[0] - 1)\n        new_y = min(max(y + movement_choice[1], 0), grid_size[1] - 1)\n        self.location = (new_x, new_y)\n\n    def interact(self, other: 'Person', transmission_rate: float):\n        \"\"\"\n        Interact with another person and potentially transmit the infection.\n        \"\"\"\n        if self.health_status == INFECTED and other.health_status == SUSCEPTIBLE:\n            if random.random() < transmission_rate:\n                other.health_status = INFECTED\n                other.recovery_time = int(np.random.exponential(1 / transmission_rate))\n        elif self.health_status == SUSCEPTIBLE and other.health_status == INFECTED:\n            if random.random() < transmission_rate:\n                self.health_status = INFECTED\n                self.recovery_time = int(np.random.exponential(1 / transmission_rate))\n\n    def recover(self):\n        \"\"\"\n        Handle the recovery process of the person.\n        \"\"\"\n        if self.health_status == INFECTED:\n            self.recovery_time -= 1\n            if self.recovery_time <= 0:\n                self.health_status = RECOVERED\n\nclass Environment:\n    \"\"\"\n    Class to manage the simulation environment.\n    \"\"\"\n\n    def __init__(self, grid_size: Tuple[int, int], population: List[Person]):\n        self.grid_size = grid_size\n        self.population = population\n        self.infection_counts = []\n        self.recovered_counts = []\n\n    def step(self, transmission_rate: float):\n        \"\"\"\n        Perform a simulation step, updating the state of the environment.\n        \"\"\"\n        # Spatial partitioning using a dictionary to manage interactions\n        location_map = {}\n        \n        for person in self.population:\n            person.move(self.grid_size)\n            loc = person.location\n            if loc not in location_map:\n                location_map[loc] = []\n            location_map[loc].append(person)\n\n        # Interactions and possible infection\n        for people in location_map.values():\n            if len(people) > 1:\n                for i, person in enumerate(people):\n                    for other in people[i + 1:]:\n                        person.interact(other, transmission_rate)\n\n        # Recovery process\n        for person in self.population:\n            person.recover()\n\n        # Track metrics\n        self.infection_counts.append(sum(1 for p in self.population if p.health_status == INFECTED))\n        self.recovered_counts.append(sum(1 for p in self.population if p.health_status == RECOVERED))\n\n    def get_metrics(self):\n        \"\"\"\n        Calculate and return the metrics of the simulation.\n        \"\"\"\n        peak_infection = max(self.infection_counts)\n        return {\n            \"infection_count\": self.infection_counts,\n            \"recovered_count\": self.recovered_counts,\n            \"peak_infection\": peak_infection\n        }\n\nclass Simulation:\n    \"\"\"\n    Class to control the simulation process.\n    \"\"\"\n\n    def __init__(self, population_size: int, initial_infected: int, grid_size: Tuple[int, int],\n                 transmission_rate: float, recovery_rate: float, random_seed: int = 42):\n        np.random.seed(random_seed)\n        random.seed(random_seed)\n\n        # Initialize population\n        self.population = []\n        for _ in range(population_size):\n            health_status = SUSCEPTIBLE\n            infection_probability = transmission_rate\n            recovery_time = 0\n            location = (random.randint(0, grid_size[0] - 1), random.randint(0, grid_size[1] - 1))\n            self.population.append(Person(health_status, infection_probability, recovery_time, location))\n\n        # Infect initial individuals\n        for person in random.sample(self.population, initial_infected):\n            person.health_status = INFECTED\n            person.recovery_time = int(np.random.exponential(1 / recovery_rate))\n\n        self.environment = Environment(grid_size, self.population)\n        self.transmission_rate = transmission_rate\n        self.grid_size = grid_size\n\n    def run(self, steps: int):\n        \"\"\"\n        Run the simulation for a specified number of steps.\n        \"\"\"\n        for _ in range(steps):\n            self.environment.step(self.transmission_rate)\n\n    def visualize(self):\n        \"\"\"\n        Visualize the results of the simulation.\n        \"\"\"\n        metrics = self.environment.get_metrics()\n        plt.figure(figsize=(12, 6))\n        plt.plot(metrics[\"infection_count\"], label=\"Infected\")\n        plt.plot(metrics[\"recovered_count\"], label=\"Recovered\")\n        plt.title(\"Epidemic Simulation\")\n        plt.xlabel(\"Days\")\n        plt.ylabel(\"Number of Individuals\")\n        plt.legend()\n        plt.show()\n\ndef main():\n    \"\"\"\n    Main function to run the epidemic simulation.\n    \"\"\"\n    # Simulation parameters\n    population_size = 1000\n    initial_infected = 10\n    grid_size = (100, 100)\n    transmission_rate = 0.1\n    recovery_rate = 0.05\n    simulation_steps = 100\n\n    # Create and run the simulation\n    sim = Simulation(population_size, initial_infected, grid_size, transmission_rate, recovery_rate)\n    sim.run(simulation_steps)\n    sim.visualize()\n\nif __name__ == \"__main__\":\n    main()",
  "code_summary": "Generated 172 lines of code containing 3 classes and 11 functions.",
  "metadata": {
    "model_type": "agent_based",
    "entities": [
      "Person"
    ],
    "behaviors": [
      "move",
      "interact",
      "recover",
      "infect"
    ]
  }
}